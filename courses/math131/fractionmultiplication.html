<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Personal website of Ben Fraser, with math education activities for students and teachers.">
  <meta charset="UTF-8" />
  <title>Fraction Multiplication Activity</title>
  <link rel="stylesheet" href="/style.css" />

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>Fraction Multiplication Activity</h1>
    <div id="nav-placeholder"></div>
    <script>
      fetch("/nav.html")
        .then(response => response.text())
        .then(html => {
          document.getElementById("nav-placeholder").innerHTML = html;

          const currentPath = window.location.pathname.replace(/\/index\.html$/, "/");
          const navLinks = document.querySelectorAll("#nav-placeholder a");
          navLinks.forEach(link => {
            const linkPath = new URL(link.href).pathname.replace(/\/index\.html$/, "/");
            if (linkPath === currentPath) {
              link.classList.add("active");
            }
          });

          const s = document.createElement("script");
          s.src = "/mascot.js";
          s.defer = true;
          document.body.appendChild(s); 
        })
        .catch(err => {
          console.error("Failed to load nav:", err);
        });
    </script>
  </header>

  <main>

    <p><i>Note that in the following, the diagrams are not drawn to scale.</i></p>

    <p>The distributive property of multiplication over addition,
      \[
      A \cdot (B + C) =
      {\color{green}AB} + {\color{orange}AC}
      \]
      has a natural interpretation as a sum of areas:
    </p>

    <figure style="text-align: center;">
      <img src="fig5.png" alt="A(B + C) = AB + AC" style="display: inline-block;">
    </figure>

    <p>This property and its geometric interpretation generalize to arbitrarily large products.  For instance, we have the well-known FOIL (first, 
    inside, outside, last) product,
    \[
      (A + B) \cdot (C + D) =
      {\color{red}AC} + {\color{blue}AD} + {\color{orange}BC} + {\color{green}BD}
    \]
    </p>

    <figure style="text-align: center;">
      <img src="fig6.png" alt="(A + B)(C + D) = AC + AD + BC + BD" style="display: inline-block;">
    </figure>
      
    <p>We will now explore how these ideas extend to products of fractions and mixed numbers, using area diagrams as a visual guide.</p>

    <div id="rule-select" class="styled-checkbox-group">
      <label>
        <input type="checkbox" class="styled-checkbox" id="proper-fractions">
        Proper Fractions
      </label>
      <label>
        <input type="checkbox" class="styled-checkbox" id="mixed-numbers">
        Mixed Numbers
      </label>
    </div>
    
    <div class="button-container">
      <button id="start-btn" class="rubber-button">Start!</button>
    </div>
    
    <p id="question-text"></p>

    <div id="decomposition-inputs" style="text-align: center; margin-bottom: 1em;"></div>

    <div id="partial-products-inputs" style="text-align: center; margin-top: 1em;"></div>

    <div id="final-answer-input" style="text-align: center; margin-top: 1em;"></div>

    <div class="button-container">
      <button id="hint-btn" class="rubber-button">Next</button>
    </div>
    
    <div id="hint-area" class="math" style="margin-top: 1em;"></div>

    <div class="activity-box" id="my-activity"></div>

    <div class="button-container">
      <button id="check-btn" class="rubber-button" style="display: none;">Check Answer</button>
    </div>
    
    <div class="button-container">
      <div id="feedbackText" class="center-feedback"></div>
    </div>

  </main>

  <script>
    // --- Checkbox handling ---------------------------------------------------

    const modeCheckboxes = {
      proper: document.getElementById('proper-fractions'),
      mixed: document.getElementById('mixed-numbers'),
    };

    Object.values(modeCheckboxes).forEach(box => {
      box.addEventListener('change', () => {
        if (box.id === 'proper-fractions' && box.checked) {
          modeCheckboxes.mixed.checked = false;
        }
        if (box.id === 'mixed-numbers' && box.checked) {
          modeCheckboxes.proper.checked = false;
        }
      });
    });

    // --- DOM references ------------------------------------------------------

    const startBtn = document.getElementById('start-btn');
    const hintBtn = document.getElementById('hint-btn');
    const checkBtn = document.getElementById('check-btn');

    const questionText = document.getElementById('question-text');
    const decompositionContainer = document.getElementById('decomposition-inputs');
    const partialProductsContainer = document.getElementById('partial-products-inputs');
    const finalAnswerContainer = document.getElementById('final-answer-input');
    const hintArea = document.getElementById('hint-area');
    const activityBox = document.getElementById('my-activity');
    const feedbackText = document.getElementById('feedbackText');

    const clickSound = document.getElementById('click-sound');

    // --- Global state --------------------------------------------------------

    let activityMode = null;  // 'proper' or 'mixed'
    let currentStep = 0;      // for mixed mode only

    // Proper fractions state: { a, b, c, d }
    // Mixed numbers state: { m1, a, b, m2, c, d, foil: [f1,f2,f3,f4], sum: frac }
    let state = {};

    // --- Fraction utilities --------------------------------------------------

    function gcd(a, b) {
      a = Math.abs(a); b = Math.abs(b);
      while (b !== 0) {
        const t = b;
        b = a % b;
        a = t;
      }
      return a || 1;
    }

    function normalizeFrac(frac) {
      let n = frac.n;
      let d = frac.d;
      if (d < 0) { n = -n; d = -d; }
      const g = gcd(n, d);
      return { n: n / g, d: d / g };
    }

    function multiplyFrac(f1, f2) {
      return normalizeFrac({ n: f1.n * f2.n, d: f1.d * f2.d });
    }

    function addFrac(f1, f2) {
      return normalizeFrac({
        n: f1.n * f2.d + f2.n * f1.d,
        d: f1.d * f2.d
      });
    }

    function fractionsEqual(f1, f2) {
      const a = normalizeFrac(f1);
      const b = normalizeFrac(f2);
      return a.n === b.n && a.d === b.d;
    }

    // Parse strings like "3", "3/5", "2 3/5", "2+3/5"
    function parseFraction(str) {
      if (!str) return null;
      const s = str.trim();
      if (!s) return null;

      // Form: "a + b/c"
      if (s.includes('+')) {
        const parts = s.split('+').map(x => x.trim());
        if (parts.length !== 2) return null;
        const whole = parseInt(parts[0], 10);
        const frac = parseFraction(parts[1]);
        if (isNaN(whole) || !frac) return null;
        return normalizeFrac({ n: whole * frac.d + frac.n, d: frac.d });
      }

      // Form: "a b/c"
      if (s.includes(' ')) {
        const parts = s.split(' ').map(x => x.trim()).filter(x => x.length > 0);
        if (parts.length !== 2) return null;
        const whole = parseInt(parts[0], 10);
        const frac = parseFraction(parts[1]);
        if (isNaN(whole) || !frac) return null;
        return normalizeFrac({ n: whole * frac.d + frac.n, d: frac.d });
      }

      // Form: "p/q"
      if (s.includes('/')) {
        const [pStr, qStr] = s.split('/');
        const p = parseInt(pStr, 10);
        const q = parseInt(qStr, 10);
        if (isNaN(p) || isNaN(q) || q === 0) return null;
        return normalizeFrac({ n: p, d: q });
      }

      // Integer
      const n = parseInt(s, 10);
      if (isNaN(n)) return null;
      return { n, d: 1 };
    }

    // Pretty TeX for mixed number m + a/b
    function mixedToTeX(m, a, b) {
      return `${m}\\dfrac{${a}}{${b}}`;
    }

    // --- Canvas helpers ------------------------------------------------------

    function getOrCreateCanvas() {
      let canvas = activityBox.querySelector('canvas');
      if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.width = 1300;
        canvas.height = 650;
        activityBox.appendChild(canvas);
      }
      return canvas;
    }

    // Proper fraction picture: a/b * c/d
    function drawProperFractionCanvas() {
      const { a, b, c, d } = state;
      const canvas = getOrCreateCanvas();
      const ctx = canvas.getContext('2d');

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const margin = 100;
      const totalWidth = 900;
      const totalHeight = 450;
      const x0 = margin;
      const y0 = margin;

      const cellWidth = totalWidth / b;
      const cellHeight = totalHeight / d;

      // Background
      ctx.fillStyle = 'white';
      ctx.fillRect(x0, y0, totalWidth, totalHeight);

      // Blue: first 'a' vertical strips
      ctx.fillStyle = 'rgba(100, 149, 237, 0.5)'; // cornflower-ish
      for (let j = 0; j < a; j++) {
        ctx.fillRect(x0 + j * cellWidth, y0, cellWidth, totalHeight);
      }

      // Red: first 'c' horizontal strips
      ctx.fillStyle = 'rgba(255, 99, 132, 0.5)';
      for (let k = 0; k < c; k++) {
        ctx.fillRect(x0, y0 + k * cellHeight, totalWidth, cellHeight);
      }

      // Draw grid over top
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      for (let j = 0; j <= b; j++) {
        const x = x0 + j * cellWidth;
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y0 + totalHeight);
        ctx.stroke();
      }
      for (let k = 0; k <= d; k++) {
        const y = y0 + k * cellHeight;
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.lineTo(x0 + totalWidth, y);
        ctx.stroke();
      }

      // Border
      ctx.lineWidth = 3;
      ctx.strokeRect(x0, y0, totalWidth, totalHeight);

      // Labels
      ctx.fillStyle = 'black';
      ctx.font = '28px Arial';
      ctx.textAlign = 'center';

      ctx.fillText(`\\(\\dfrac{${a}}{${b}}\\)`, x0 + totalWidth / 2, y0 - 20);
      ctx.save();
      ctx.translate(x0 - 50, y0 + totalHeight / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(`\\(\\dfrac{${c}}{${d}}\\)`, 0, 0);
      ctx.restore();

      // Trigger MathJax for the labels (they are drawn as text, but we also show algebraic question elsewhere)
    }

    // Mixed-number picture: (m1 + a/b)*(m2 + c/d)
    function drawMixedCanvas() {
      const { m1, a, b, m2, c, d } = state;
      const canvas = getOrCreateCanvas();
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const margin = 100;
      const totalWidthPx = 900;
      const totalHeightPx = 450;
      const x0 = margin;
      const y0 = margin;

      const totalWidthUnits = m1 + a / b;
      const totalHeightUnits = m2 + c / d;

      const unitW = totalWidthPx / totalWidthUnits;
      const unitH = totalHeightPx / totalHeightUnits;

      // Regions:
      // Base green rectangle: [0, m1] x [0, m2]
      ctx.fillStyle = 'rgba(144, 238, 144, 0.8)'; // light green
      ctx.fillRect(x0, y0, m1 * unitW, m2 * unitH);

      // Blue strip: fractional part horizontally: [m1, m1 + a/b] x [0, m2]
      ctx.fillStyle = 'rgba(135, 206, 250, 0.7)'; // light blue
      ctx.fillRect(x0 + m1 * unitW, y0, (a / b) * unitW, m2 * unitH);

      // Red strip: fractional part vertically: [0, m1] x [m2, m2 + c/d]
      ctx.fillStyle = 'rgba(255, 99, 132, 0.5)';
      ctx.fillRect(x0, y0 + m2 * unitH, m1 * unitW, (c / d) * unitH);

      // Purple intersection: [m1, m1 + a/b] x [m2, m2 + c/d]
      ctx.fillStyle = 'rgba(186, 85, 211, 0.7)';
      ctx.fillRect(
        x0 + m1 * unitW,
        y0 + m2 * unitH,
        (a / b) * unitW,
        (c / d) * unitH
      );

      // Grid lines:
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;

      // Vertical integer lines
      for (let i = 0; i <= m1; i++) {
        const x = x0 + i * unitW;
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y0 + totalHeightPx);
        ctx.stroke();
      }

      // Within the fractional part horizontally:
      const fracStepW = unitW / b; // fractional part length a/b * unitW is subdivided into a segments of length 1/b * unitW
      for (let j = 0; j <= a; j++) {
        const x = x0 + m1 * unitW + j * fracStepW;
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y0 + totalHeightPx);
        ctx.stroke();
      }

      // Horizontal integer lines
      for (let k = 0; k <= m2; k++) {
        const y = y0 + k * unitH;
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.lineTo(x0 + totalWidthPx, y);
        ctx.stroke();
      }

      // Within the fractional part vertically:
      const fracStepH = unitH / d;
      for (let j = 0; j <= c; j++) {
        const y = y0 + m2 * unitH + j * fracStepH;
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.lineTo(x0 + totalWidthPx, y);
        ctx.stroke();
      }

      // Outer rectangle
      ctx.lineWidth = 3;
      ctx.strokeRect(x0, y0, totalWidthPx, totalHeightPx);

      // Labels from inputs (if present)
      ctx.fillStyle = 'black';
      ctx.font = '28px Arial';
      ctx.textAlign = 'center';

      // Step 2 inputs (FOIL) labelled in their corresponding regions
      const foilInputs = document.querySelectorAll('.step2-input');
      if (foilInputs.length === 4) {
        const values = Array.from(foilInputs).map(inp => inp.value.trim()).map(v => v || '');

        // 0: m1*m2 (green block)
        if (values[0]) {
          const x = x0 + (m1 * unitW) / 2;
          const y = y0 + (m2 * unitH) / 2;
          ctx.fillText(values[0], x, y);
        }
        // 1: m1 * (c/d) (red strip above green)
        if (values[1]) {
          const x = x0 + (m1 * unitW) / 2;
          const y = y0 + m2 * unitH + ((c / d) * unitH) / 2;
          ctx.fillText(values[1], x, y);
        }
        // 2: (a/b) * m2 (blue strip to the right)
        if (values[2]) {
          const x = x0 + m1 * unitW + ((a / b) * unitW) / 2;
          const y = y0 + (m2 * unitH) / 2;
          ctx.fillText(values[2], x, y);
        }
        // 3: (a/b)*(c/d) (purple corner)
        if (values[3]) {
          const x = x0 + m1 * unitW + ((a / b) * unitW) / 2;
          const y = y0 + m2 * unitH + ((c / d) * unitH) / 2;
          ctx.fillText(values[3], x, y);
        }
      }
    }

    // --- UI reset ------------------------------------------------------------

    function resetUI() {
      questionText.textContent = '';
      decompositionContainer.innerHTML = '';
      partialProductsContainer.innerHTML = '';
      finalAnswerContainer.innerHTML = '';
      hintArea.innerHTML = '';
      feedbackText.textContent = '';
      feedbackText.style.color = '';
      activityBox.innerHTML = ''; // remove canvas

      currentStep = 0;

      hintBtn.disabled = true;
      checkBtn.style.display = 'none';
    }

    function playClickSound() {
      if (clickSound) {
        clickSound.currentTime = 0;
        clickSound.play();
      }
    }

    // --- Proper fraction mode ------------------------------------------------

    function initProperProblem() {
      activityMode = 'proper';
      currentStep = 1;
      hintBtn.disabled = true;

      // Random proper fractions with denominators between 2 and 15
      const b = Math.floor(Math.random() * 14) + 2; // 2..15
      const d = Math.floor(Math.random() * 14) + 2;
      const a = Math.floor(Math.random() * (b - 1)) + 1;
      const c = Math.floor(Math.random() * (d - 1)) + 1;

      state = { a, b, c, d };

      questionText.textContent =
        `What is \\(\\dfrac{${a}}{${b}} \\cdot \\dfrac{${c}}{${d}}\\)?`;
      if (window.MathJax && MathJax.typesetPromise) {
        MathJax.typesetPromise([questionText]);
      }

      // Answer input: unsimplified product (a*c)/(b*d)
      const prodNum = a * c;
      const prodDen = b * d;
      state.prodNum = prodNum;
      state.prodDen = prodDen;

      finalAnswerContainer.innerHTML = `
        = 
        <input type="text" id="proper-num" style="width: 60px; text-align: center;" /> 
        /
        <input type="text" id="proper-den" style="width: 60px; text-align: center;" />
      `;

      const numInput = document.getElementById('proper-num');
      const denInput = document.getElementById('proper-den');

      checkBtn.style.display = 'inline-block';

      function checkProperAnswer() {
        const n = parseInt(numInput.value, 10);
        const dVal = parseInt(denInput.value, 10);

        let correct = true;
        if (isNaN(n) || n !== prodNum) correct = false;
        if (isNaN(dVal) || dVal !== prodDen) correct = false;

        if (correct) {
          numInput.style.backgroundColor = '#c8f7c5';
          denInput.style.backgroundColor = '#c8f7c5';
          feedbackText.textContent = 'Correct!';
          feedbackText.style.color = 'green';
        } else {
          numInput.style.backgroundColor = '#f8d7da';
          denInput.style.backgroundColor = '#f8d7da';
          feedbackText.textContent = 'Incorrect. Try again!';
          feedbackText.style.color = 'red';
        }
      }

      checkBtn.onclick = () => {
        playClickSound();
        checkProperAnswer();
      };

      drawProperFractionCanvas();
    }

    // --- Mixed numbers mode --------------------------------------------------

    function initMixedProblem() {
      activityMode = 'mixed';
      currentStep = 1;
      hintBtn.disabled = true;

      // Choose nice-ish ranges so the picture isn't too insane.
      const b = Math.floor(Math.random() * 8) + 2; // 2..9
      const d = Math.floor(Math.random() * 8) + 2;
      const a = Math.floor(Math.random() * (b - 1)) + 1;
      const c = Math.floor(Math.random() * (d - 1)) + 1;

      const m1 = Math.floor(Math.random() * 3) + 1; // 1..3
      const m2 = Math.floor(Math.random() * 3) + 1;

      state = { m1, a, b, m2, c, d };

      const texMixed1 = mixedToTeX(m1, a, b);
      const texMixed2 = mixedToTeX(m2, c, d);

      questionText.textContent =
        `What is \\(${texMixed1} \\cdot ${texMixed2}\\)?`;
      if (window.MathJax && MathJax.typesetPromise) {
        MathJax.typesetPromise([questionText]);
      }

      // Step 1: Decompose into (m1 + a/b)(m2 + c/d)
      decompositionContainer.innerHTML = `
        = 
        ( 
          <input type="text" class="step1-input" data-kind="m1" style="width: 50px; text-align: center;" /> 
          +
          <input type="text" class="step1-input" data-kind="frac1" style="width: 70px; text-align: center;" /> 
        )
        (
          <input type="text" class="step1-input" data-kind="m2" style="width: 50px; text-align: center;" /> 
          +
          <input type="text" class="step1-input" data-kind="frac2" style="width: 70px; text-align: center;" /> 
        )
      `;

      const step1Inputs = decompositionContainer.querySelectorAll('.step1-input');

      function validateStep1() {
        let allCorrect = true;
        step1Inputs.forEach(inp => {
          const kind = inp.dataset.kind;
          const value = inp.value.trim();
          let correct = false;

          if (kind === 'm1') {
            const v = parseInt(value, 10);
            correct = (!isNaN(v) && v === m1);
          } else if (kind === 'm2') {
            const v = parseInt(value, 10);
            correct = (!isNaN(v) && v === m2);
          } else if (kind === 'frac1') {
            const frac = parseFraction(value);
            correct = frac && fractionsEqual(frac, { n: a, d: b });
          } else if (kind === 'frac2') {
            const frac = parseFraction(value);
            correct = frac && fractionsEqual(frac, { n: c, d: d });
          }

          if (correct) {
            inp.style.backgroundColor = '#c8f7c5';
          } else {
            inp.style.backgroundColor = '#f8d7da';
            allCorrect = false;
          }
        });

        hintBtn.disabled = !allCorrect;
        drawMixedCanvas();
      }

      step1Inputs.forEach(inp => {
        inp.addEventListener('input', validateStep1);
      });

      drawMixedCanvas();
    }

    function goToStep2() {
      const { m1, a, b, m2, c, d } = state;

      // Freeze step 1 inputs
      const step1Inputs = decompositionContainer.querySelectorAll('.step1-input');
      step1Inputs.forEach(inp => inp.disabled = true);

      // Step 2: FOIL partial products
      // (m1 + a/b)(m2 + c/d) =
      // 1) m1*m2
      // 2) m1*(c/d)
      // 3) (a/b)*m2
      // 4) (a/b)*(c/d)

      const f1 = multiplyFrac({ n: m1, d: 1 }, { n: m2, d: 1 });
      const f2 = multiplyFrac({ n: m1, d: 1 }, { n: c, d: d });
      const f3 = multiplyFrac({ n: a, d: b }, { n: m2, d: 1 });
      const f4 = multiplyFrac({ n: a, d: b }, { n: c, d: d });

      state.foil = [f1, f2, f3, f4];

      partialProductsContainer.innerHTML = `
        = 
        <input type="text" class="step2-input" data-index="0" style="width: 80px; text-align: center;" /> 
        +
        <input type="text" class="step2-input" data-index="1" style="width: 80px; text-align: center;" /> 
        +
        <input type="text" class="step2-input" data-index="2" style="width: 80px; text-align: center;" /> 
        +
        <input type="text" class="step2-input" data-index="3" style="width: 80px; text-align: center;" />
      `;

      const step2Inputs = partialProductsContainer.querySelectorAll('.step2-input');

      function validateStep2() {
        let allCorrect = true;
        step2Inputs.forEach(inp => {
          const idx = parseInt(inp.dataset.index, 10);
          const val = inp.value.trim();
          const frac = parseFraction(val);
          const expected = state.foil[idx];

          const correct = frac && fractionsEqual(frac, expected);
          if (correct) {
            inp.style.backgroundColor = '#c8f7c5';
          } else {
            inp.style.backgroundColor = '#f8d7da';
            allCorrect = false;
          }
        });

        hintBtn.disabled = !allCorrect;
        drawMixedCanvas();
      }

      step2Inputs.forEach(inp => {
        inp.addEventListener('input', validateStep2);
      });

      hintBtn.disabled = true;
      drawMixedCanvas();
    }

    function goToStep3() {
      // Freeze step 2 inputs
      const step2Inputs = partialProductsContainer.querySelectorAll('.step2-input');
      step2Inputs.forEach(inp => inp.disabled = true);

      const sum = state.foil.reduce((acc, f) => addFrac(acc, f), { n: 0, d: 1 });
      state.sum = sum;

      finalAnswerContainer.innerHTML = `
        = <input type="text" id="mixed-final" style="width: 120px; text-align: center;" />
      `;

      const finalInput = document.getElementById('mixed-final');

      function validateFinal() {
        const frac = parseFraction(finalInput.value.trim());
        const correct = frac && fractionsEqual(frac, state.sum);

        if (correct) {
          finalInput.style.backgroundColor = '#c8f7c5';
          feedbackText.textContent = 'Correct!';
          feedbackText.style.color = 'green';
          hintBtn.disabled = true;
        } else {
          finalInput.style.backgroundColor = '#f8d7da';
          feedbackText.textContent = '';
          hintBtn.disabled = true; // stay disabled until correct? up to you
        }
      }

      finalInput.addEventListener('input', validateFinal);
      hintBtn.disabled = true;
    }

    // --- Event wiring --------------------------------------------------------

    startBtn.addEventListener('click', () => {
      playClickSound();
      resetUI();

      if (modeCheckboxes.proper.checked) {
        initProperProblem();
      } else if (modeCheckboxes.mixed.checked) {
        initMixedProblem();
      } else {
        feedbackText.textContent = 'Please select either "Proper Fractions" or "Mixed Numbers" first.';
        feedbackText.style.color = 'red';
      }
    });

    hintBtn.addEventListener('click', () => {
      playClickSound();
      if (activityMode !== 'mixed') return;

      if (currentStep === 1) {
        currentStep = 2;
        goToStep2();
      } else if (currentStep === 2) {
        currentStep = 3;
        goToStep3();
      }
    });

    // For proper-fraction mode, checkBtn is wired inside initProperProblem.
  </script>

  <audio id="click-sound" src="button.mp3" preload="auto"></audio>
  <audio id="set-sound" src="set2.mp3" preload="auto"></audio>
  
</body>
</html>
