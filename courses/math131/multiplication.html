

<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Personal website of Ben Fraser, with math education activities for students and teachers.">
  <meta charset="UTF-8" />
  <title>Multiplication Activity</title>
  <link rel="stylesheet" href="/style.css" />

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>Multiplication Activity</h1>
    <div id="nav-placeholder"></div>
      <script>
        fetch("/nav.html")
          .then(response => response.text())
          .then(data => {
            document.getElementById("nav-placeholder").innerHTML = data;
        
            const currentPath = window.location.pathname.replace(/\/index\.html$/, "/");
            const navLinks = document.querySelectorAll("#nav-placeholder a");
        
            navLinks.forEach(link => {
              const linkPath = new URL(link.href).pathname.replace(/\/index\.html$/, "/");
              if (linkPath === currentPath) {
                link.classList.add("active");
              }
            });
          });
      </script>
  </header>
  <main>

    <p><i>Note that in the following, the diagrams are not drawn to scale.</i></p>

    <p>The distributive property of multiplication over addition, \[A \cdot (B + C) = 
      {\color{green}AB} + {\color{orange}AC}\] has a natural interpretation as a sum 
      of areas:</p>

    <figure style="text-align: center;">
      <img src="fig5.png" alt="A(B + C) = AB + AC" style="display: inline-block;">
    </figure>

    <p>This property and its geometric interpretation generalize to arbitrarily large products.  For instance, we have the well-known FOIL (first, 
    inside, outside, last) product, \[(A + B) \cdot (C + D) = {\color{red}AC} + {\color{blue}AD} + {\color{orange}BC} + {\color{green}BD}\]</p>

    <figure style="text-align: center;">
      <img src="fig6.png" alt="(A + B)(C + D) = AC + AD + BC + BD" style="display: inline-block;">
    </figure>
      
      <p>For an even larger example, consider \[(A + B + C) \cdot (D + E + F) = {\color{red}AD} + {\color{orange}AE} + {\color{yellow}AF} + 
        {\color{blue}BD} + {\color{green}BE} + {\color{purple}BF} + {\color{pink}CD} + {\color{brown}CE} + {\color{grey}CF}\]</p>
    
    <figure style="text-align: center;">
      <img src="fig7.png" alt="(A + B + C)(D + E + F) = AD + AE + AF + BD + BE + BF + CD + CE + CF" style="display: inline-block;">
    </figure>
    
    <p>Consider the implications of this property for breaking down a difficult multiplication problem: we can break the two multiplicand decimal numbers 
      down into sums of their respective place values, and then use the distributive law to instead compute a sum of simpler products.  This is called 
    the <i>partial product</i> method, and has the same natural interpretation in terms of areas.  For instance, consider the problem</p>

    <div style="text-align: center;">
    <p>\(\begin{aligned}249 \cdot 63 = (200 + 40 + 9) \cdot (60 + 3) & = {\color{red}200 \cdot 60} + {\color{orange}200 \cdot 3} + 
      {\color{yellow}40 \cdot 60} + {\color{green}40 \cdot 3} + {\color{blue}9 \cdot 60} + {\color{purple}9 \cdot 3}\\ & = {\color{red}12000} + 
      {\color{orange}600} + {\color{yellow}2400} + {\color{green}120} + {\color{blue}540} + {\color{purple}27}\\ & = 15687 \end{aligned}\)</p>
    </div>

    <figure style="text-align: center;">
      <img src="fig8.png" alt="(200 + 40 + 9)(60 + 3) = 200(60) + 200(3) + 40(60) + 40(3) + 9(60) + 9(3)" style="display: inline-block;">
    </figure>

    
    <div class="button-container">
      <button id="start-btn" class="rubber-button">Start!</button>
    </div>
    
    <p id="question-text"></p>

    <div id="decomposition-inputs" style="text-align: center; margin-bottom: 1em;"></div>

    <div class="button-container">
      <button id="hint-btn" class="rubber-button">Next</button>
    </div>
    
    <div id="hint-area" class="math" style="margin-top: 1em;"></div>

    <div class="activity-box" id="my-activity">

    </div>

    <div class="button-container">
      <button id="check-btn" class="rubber-button">Check Answer</button>
    </div>
    
    <div class="button-container">
      <div id="feedbackText" class="center-feedback"></div>
    </div>





  </main>

  <script>

    let a, b;

    const hintBtn = document.getElementById('hint-btn');
    const hintArea = document.getElementById('hint-area');
    

    const startBtn = document.getElementById('start-btn');
    const questionText = document.getElementById('question-text');
    const activityBox = document.getElementById('my-activity');


    function drawCanvas(mode, inputElements) {
      activityBox.innerHTML = ''; // clear
      const canvas = document.createElement('canvas');
      canvas.width = 1300;
      canvas.height = 650;
      activityBox.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 4;

      if (mode === 1) {
        ctx.strokeRect(375, 80, 550, 550);
        ctx.fillStyle = 'red';
        ctx.fillRect(375, 80, 440, 440);
        ctx.fillStyle = 'skyblue';
        ctx.fillRect(815, 80, 110, 440);
        ctx.fillStyle = 'orange';
        ctx.fillRect(375, 520, 440, 110);
        ctx.fillStyle = 'lime';
        ctx.fillRect(815, 520, 110, 110);
        ctx.strokeRect(375, 80, 440, 440);
        ctx.strokeRect(815, 80, 110, 440);
        ctx.strokeRect(375, 520, 440, 110);
        ctx.strokeRect(815, 520, 110, 110);
      } else if (mode === 2) {
        ctx.fillStyle = 'red';
        ctx.fillRect(450, 80, 320, 390);
        ctx.fillStyle = 'orange';
        ctx.fillRect(770, 80, 80, 390);
        ctx.fillStyle = 'yellow';
        ctx.fillRect(450, 470, 320, 110);
        ctx.fillStyle = 'lime';
        ctx.fillRect(770, 470, 80, 110);
        ctx.fillStyle = 'skyblue';
        ctx.fillRect(450, 580, 320, 50);
        ctx.fillStyle = 'violet';
        ctx.fillRect(770, 580, 80, 50);
        ctx.strokeRect(450, 80, 400, 550);
        ctx.strokeRect(450, 80, 320, 390);
        ctx.strokeRect(770, 80, 80, 390);
        ctx.strokeRect(450, 470, 320, 110);
        ctx.strokeRect(770, 470, 80, 110);
        ctx.strokeRect(450, 580, 320, 50);
        ctx.strokeRect(770, 580, 80, 50);
      } else if (mode === 3) {
        ctx.fillStyle = 'red';
        ctx.fillRect(375, 80, 390, 390);
        ctx.fillStyle = 'orange';
        ctx.fillRect(765, 80, 110, 390);
        ctx.fillStyle = 'yellow';
        ctx.fillRect(875, 80, 50, 390);
        ctx.fillStyle = 'skyblue';
        ctx.fillRect(375, 470, 390, 110);
        ctx.fillStyle = 'lime';
        ctx.fillRect(765, 470, 110, 110);
        ctx.fillStyle = 'violet';
        ctx.fillRect(875, 470, 50, 110);
        ctx.fillStyle = 'pink';
        ctx.fillRect(375, 580, 390, 50);
        ctx.fillStyle = 'rgba(163,114,65,0.8)';
        ctx.fillRect(765, 580, 110, 50);
        ctx.fillStyle = 'lightgray';
        ctx.fillRect(875, 580, 50, 50);
        ctx.strokeRect(375, 80, 550, 550);
        ctx.strokeRect(375, 80, 390, 390);
        ctx.strokeRect(765, 80, 110, 390);
        ctx.strokeRect(875, 80, 50, 390);
        ctx.strokeRect(375, 470, 390, 110);
        ctx.strokeRect(765, 470, 110, 110);
        ctx.strokeRect(875, 470, 50, 110);
        ctx.strokeRect(375, 580, 390, 50);
        ctx.strokeRect(765, 580, 110, 50);
        ctx.strokeRect(875, 580, 50, 50);
      }
    
      // Now draw the label values
      ctx.font = "bold 48px Arial";
      ctx.fillStyle = "black";

      ctx.textAlign = "center"; // default for top labels

    
      inputElements.forEach((input, index) => {
      const val = input.value;
      if (!isNaN(val) && val.trim() !== "") {
        let x = 0, y = 0;
    
        if (mode === 1) {
          if (index === 0) {
            ctx.textAlign = "right"
            x = 370;
            y = 330;
          } else if (index === 1) {
            ctx.textAlign = "right"
            x = 370;
            y = 590;
          } else if (index === 2) {
            ctx.textAlign = "center"
            x = 595;
            y = 70;
          } else if (index === 3) {
            ctx.textAlign = "center"
            x = 870;
            y = 70;
          }
        } else if (mode === 2) {
          if (index === 0) {
            ctx.textAlign = "right"
            x = 370;
            y = 300;
          } else if (index === 1) {
            ctx.textAlign = "right"
            x = 370;
            y = 560;
          } else if (index === 2) {
            ctx.textAlign = "right"
            x = 370;
            y = 620;
          } else if (index === 3) {
            ctx.textAlign = "center"
            x = 545;
            y = 70;
          } else if (index === 4) {
            ctx.textAlign = "center"
            x = 850;
            y = 70;
          }
        } else if (mode === 3) {
          if (index < 3) {
            ctx.textAlign = "right"
            x = 400 + index * 200;
            y = 70;
          } else {
            ctx.textAlign = "center"
            x = 950;
            y = 470 + (index - 3) * 50;
          }
        }
    
        ctx.fillText(val, x, y);
      }
    });

    }








    
  startBtn.addEventListener('click', () => {

      const feedback = document.getElementById('feedbackText');
      feedback.textContent = '';

      // Play sound when view button is clicked
      const sound = document.getElementById('click-sound');
      if (sound) {
        sound.currentTime = 0; // rewind to start in case it's still playing
        sound.play();
      }

      // Choose the mode, 1 is 2-digit*2-digit, 2 is 3-digit*2-digit, 3 is 3-digit*3-digit
      let mode = Math.floor(Math.random() * 3) + 1;

      if (mode === 1) {
        a = Math.floor(Math.random() * 90) + 10;
        b = Math.floor(Math.random() * 90) + 10;
      } else if (mode === 2) {
        a = Math.floor(Math.random() * 900) + 100;
        b = Math.floor(Math.random() * 90) + 10;
      } else {
        a = Math.floor(Math.random() * 900) + 100;
        b = Math.floor(Math.random() * 900) + 100;
      }

    
      hintSteps = [];
      hintIndex = 0;
      let i = 0

  
      // Display the question
      questionText.textContent = `What is \\(${a} \\cdot ${b}\\)?`;

      MathJax.typeset([questionText]);

      
      // Clear the activity box
      activityBox.innerHTML = '';

      const decompositionContainer = document.getElementById('decomposition-inputs');
      decompositionContainer.innerHTML = ''; // Clear previous inputs
      
      const aDigits = a.toString().split('').map(Number);
      const bDigits = b.toString().split('').map(Number);
      
      const aParts = [];
      const bParts = [];
      
      for (let i = 0; i < aDigits.length; i++) {
        const place = Math.pow(10, aDigits.length - 1 - i);
        aParts.push(aDigits[i] * place);
      }
      for (let i = 0; i < bDigits.length; i++) {
        const place = Math.pow(10, bDigits.length - 1 - i);
        bParts.push(bDigits[i] * place);
      }
      
      const inputBox = (index, total, name) => `<input type="text" data-expected="${name[index]}" class="decomp-input" style="width: 50px; text-align: center;" />`;
      
      // Generate the HTML for the input boxes
      let html = '= (';
      html += aParts.map((_, i) => inputBox(i, aParts.length, aParts)).join(' + ');
      html += ') Ã— (';
      html += bParts.map((_, i) => inputBox(i, bParts.length, bParts)).join(' + ');
      html += ')';
      
      decompositionContainer.innerHTML = html;

      // Attach event listeners to validate input values and color them
      const inputElements = decompositionContainer.querySelectorAll('.decomp-input');
      inputElements.forEach(input => {
      input.addEventListener('input', () => {
        const expected = parseInt(input.dataset.expected);
        const value = parseInt(input.value);
    
        if (!isNaN(value) && value === expected) {
          input.style.backgroundColor = '#c8f7c5';  // light green
        } else {
          input.style.backgroundColor = '#f8d7da';  // light red
        }
    
        // Redraw the canvas labels
        drawCanvas(mode, inputElements);
      });
    });



      


      hintIndex = 0;
      hintArea.innerHTML = "";  // Clear previous hints

      drawCanvas(mode, inputElements);



    });


    const checkBtn = document.getElementById('check-btn');
    const feedbackText = document.getElementById('feedbackText');
    
    checkBtn.addEventListener('click', () => {
      // Play click sound
      const sound = document.getElementById('click-sound');
      if (sound) {
        sound.currentTime = 0;
        sound.play();
      }
    
      let correct = true;
    
      // Give feedback
      if (correct) {
        feedbackText.textContent = "Correct!";
        feedbackText.style.color = "green";
      } else {
        feedbackText.textContent = "Incorrect. Try again!";
        feedbackText.style.color = "red";
      }
    });


    hintBtn.addEventListener('click', () => {
      // Play sound when view button is clicked
      const sound = document.getElementById('click-sound');
      if (sound) {
        sound.currentTime = 0; // rewind to start in case it's still playing
        sound.play();
      }
      if (hintIndex < hintSteps.length) {
        // Create a new paragraph for each hint
        const hintPara = document.createElement('div');
        hintPara.classList.add('hint-step');
        hintPara.textContent = hintSteps[hintIndex];
        hintArea.appendChild(hintPara);
        
        MathJax.typeset([hintPara]);
        hintIndex++;
      }
    });

    
  </script>

  <audio id="click-sound" src="button.mp3" preload="auto"></audio>
  <audio id="set-sound" src="set2.mp3" preload="auto"></audio>
  
</body>
</html>
