
<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Personal website of Ben Fraser, with math education activities for students and teachers.">
  <meta charset="UTF-8" />
  <title>Prime Factorization Activity</title>
  <link rel="stylesheet" href="/style.css" />

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>Prime Factorization Activity</h1>
    <div id="nav-placeholder"></div>
      <script>
fetch("/nav.html")
  .then(response => response.text())
  .then(html => {
    document.getElementById("nav-placeholder").innerHTML = html;

    const currentPath = window.location.pathname.replace(/\/index\.html$/, "/");
    const navLinks = document.querySelectorAll("#nav-placeholder a");
    navLinks.forEach(link => {
      const linkPath = new URL(link.href).pathname.replace(/\/index\.html$/, "/");
      if (linkPath === currentPath) {
        link.classList.add("active");
      }
    });

    const s = document.createElement("script");
    s.src = "/mascot.js";
    s.defer = true;
    document.body.appendChild(s); 
  })
  .catch(err => {
    console.error("Failed to load nav:", err);
  });
</script>
  </header>
  <main>

    <p>This is a placeholder for what will be a prime factorization activity.  Work in progress.</p>
    
    <div class="button-container">
      <button id="start-btn" class="rubber-button">Start!</button>
    </div>
    
    <p id="question-text"></p>

    <div class="activity-box" id="my-activity">

    </div>
    
    <div class="button-container">
      <div id="feedbackText" class="center-feedback"></div>
    </div>

  </main>

  <script>


    let a = 0, a2 = 0, a3 = 0, a5 = 0, a7 = 0, a11 = 0, an = 0, anum = 0;
    let b = 0, b2 = 0, b3 = 0, b5 = 0, b7 = 0, b11 = 0, bn = 0, bnum = 0;


    const startBtn = document.getElementById('start-btn');
    const questionText = document.getElementById('question-text');
    const activityBox = document.getElementById('my-activity');


        function addTextToActivityBox(text, x, y, fontSize = 28) {
      const txt = document.createElement('div');
      txt.classList.add('activity-text');
      txt.textContent = text;
      txt.style.left = `${x}px`;
      txt.style.top = `${y}px`;
      txt.style.fontSize = `${fontSize}px`;
      activityBox.appendChild(txt);
    }


    // --- Utilities ---
    function isPrime(n) {
      if (n < 2) return false;
      if (n % 2 === 0) return n === 2;
      const r = Math.floor(Math.sqrt(n));
      for (let d = 3; d <= r; d += 2) if (n % d === 0) return false;
      return true;
    }
    
    function primeFactorCount(n) {
      // counts with multiplicity, e.g., 12 = 2^2 * 3 => 3
      let count = 0, m = n;
      for (let p = 2; p * p <= m; p += (p === 2 ? 1 : 2)) {
        while (m % p === 0) { count++; m = Math.trunc(m / p); }
      }
      if (m > 1) count++;
      return count;
    }
    
    // Center a flexible-width box at an x center and y top
    function placeCentered(el, centerX, topY) {
      el.style.left = `${centerX}px`;
      el.style.top = `${topY}px`;
      el.style.position = 'absolute';
      el.style.transform = 'translateX(-50%)';
    }
    
    // Draw a line on the canvas between two DOM elements (box centers, bottom-to-top)
    function connectBoxes(ctx, parentEl, childEl) {
      const p = parentEl.getBoundingClientRect();
      const c = childEl.getBoundingClientRect();
      const canvasRect = ctx.canvas.getBoundingClientRect();
    
      const parentCenterX = p.left + p.width / 2 - canvasRect.left;
      const parentBottomY = p.top + p.height - canvasRect.top;
    
      const childCenterX = c.left + c.width / 2 - canvasRect.left;
      const childTopY = c.top - canvasRect.top;
    
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(parentCenterX, parentBottomY);
      ctx.lineTo(childCenterX, childTopY);
      ctx.stroke();
    }


    function createNumberLeaf({
      value, centerX, topY, totalAnum,
      segmentLeft, segmentRight, ctx,
      totalWidth = 1300,  // NEW default
      boxHeight = 80      // NEW default
    }) {
      const isP = isPrime(value);
      const box = document.createElement('div');
      box.className = isP ? 'prime-box' : 'composite-box';
      box.textContent = value.toString();
      activityBox.appendChild(box);
      placeCentered(box, centerX, topY);
    
      if (isP) return { box, value, leaf: true };
    
      const controls = document.createElement('div');
      controls.className = 'leaf-controls';
      placeCentered(controls, centerX, topY + boxHeight + 8); // was +88; now uses boxHeight
      const input = document.createElement('input');
      input.type = 'number';
      input.placeholder = 'Enter divisor';
      input.min = '2';
      input.step = '1';
    
      const tryBtn = document.createElement('button');
      tryBtn.className = 'rubber-button';
      tryBtn.textContent = 'Try Divisor';
    
      controls.appendChild(input);
      controls.appendChild(tryBtn);
      activityBox.appendChild(controls);
    
      tryBtn.addEventListener('click', () => {
        const c = parseInt(input.value, 10);
        if (!c || c < 2) return;
        if (value % c !== 0) return;
    
        const d = value / c;
    
        const cnum = primeFactorCount(c);
        const dnum = primeFactorCount(d);
    
        // totalWidth is now passed in (650 for each side)
        const leftWidth = totalWidth * (cnum / totalAnum);
        const rightWidth = totalWidth * (dnum / totalAnum);
    
        const leftCenter = (segmentLeft ?? 0) + leftWidth / 2;
        const rightCenter = (segmentRight ?? totalWidth) - rightWidth / 2;
    
        controls.remove();
    
        const childTop = topY + 110; // increased vertical spacing between generations
    
        const leftChild = createNumberLeaf({
          value: c,
          centerX: leftCenter,
          topY: childTop,
          totalAnum,
          segmentLeft: (segmentLeft ?? 0),
          segmentRight: (segmentLeft ?? 0) + leftWidth,
          ctx,
          totalWidth,             // pass through 650
          boxHeight               // pass through 64
        });
    
        const rightChild = createNumberLeaf({
          value: d,
          centerX: rightCenter,
          topY: childTop,
          totalAnum,
          segmentLeft: (segmentRight ?? totalWidth) - rightWidth,
          segmentRight: (segmentRight ?? totalWidth),
          ctx,
          totalWidth,             // pass through 650
          boxHeight               // pass through 64
        });
    
        connectBoxes(ctx, box, leftChild.box);
        connectBoxes(ctx, box, rightChild.box);
        maybeRenderExponentStage(a, b);
      });
    
      return { box, value, leaf: false };
    }


    
    // Return Map<prime, exponent>
    function factorMap(n) {
      const map = new Map();
      let m = n;
      for (let p = 2; p * p <= m; p += (p === 2 ? 1 : 2)) {
        while (m % p === 0) { map.set(p, (map.get(p) || 0) + 1); m = Math.trunc(m / p); }
      }
      if (m > 1) map.set(m, (map.get(m) || 0) + 1);
      return map;
    }
    
    // Build a “result product” row (for gcd / lcm) with empty superscripts to fill later
    function buildResultRow(label, primesUnion) {
      const wrap = document.createElement('div');
      wrap.className = 'exp-result';
    
      const lbl = document.createElement('span');
      lbl.style.fontWeight = '700';
      lbl.textContent = `${label} =`;
      wrap.appendChild(lbl);
    
      primesUnion.forEach((p, idx) => {
        if (idx > 0) {
          const times = document.createElement('span');
          times.className = 'exp-times';
          times.textContent = '×';
          wrap.appendChild(times);
        }
        const term = document.createElement('span');
        term.className = 'exp-term';
    
        const baseSpan = document.createElement('span');
        baseSpan.textContent = p.toString();
        term.appendChild(baseSpan);
    
        // empty superscript container; we’ll fill it later
        const sup = document.createElement('span');
        sup.className = 'exp-sup';
        sup.dataset.prime = String(p);
        term.appendChild(sup);
    
        wrap.appendChild(term);
      });
    
      return wrap;
    }


    /// Stage 3: after all stage-2 exponents are filled, render reduction activity
    function maybeRenderReductionStage(aVal, bVal, fa, fb, primesUnion) {

      let stage4Started = false;
      // Compute gcd exponents (mins)
      const gcdExp = new Map();
      primesUnion.forEach(p => {
        const ea = fa.get(p) || 0, eb = fb.get(p) || 0;
        gcdExp.set(p, Math.min(ea, eb));
      });
    
      // Target exponents after dividing by gcd:
      const targetNum = new Map();  // a - gcd
      const targetDen = new Map();  // b - gcd
      primesUnion.forEach(p => {
        const ea = fa.get(p) || 0, eb = fb.get(p) || 0, g = gcdExp.get(p) || 0;
        targetNum.set(p, ea - g);
        targetDen.set(p, eb - g);
      });
    
      // Question paragraph
      const q3 = document.createElement('p');
      q3.textContent = 'Reduce the following fraction to lowest form, by dividing the numerator and denominator by the gcd.  That is, subtract the gcd exponents from the original exponents (so we "cancel" from the top and bottom).';
      q3.style.textAlign = 'center';
      q3.style.fontWeight = 'bold';
      activityBox.parentElement.appendChild(q3);
    
      // Box
      const box3 = document.createElement('div');
      box3.className = 'activity-box-short';
      box3.id = 'reduction-activity';
      box3.style.marginTop = '10px';
      activityBox.parentElement.appendChild(box3);
    
      // Left: MathJax fraction a/b (large via CSS)
      const leftFrac = document.createElement('span');
      leftFrac.textContent = `\\(\\dfrac{${aVal}}{${bVal}}\\)`;
    
      // "="
      const eq1 = document.createElement('span');
      eq1.className = 'reduce-equals';
      eq1.textContent = '=';
    
      // ---------- Non-interactive prime-decomposition fraction ----------
      const midFrac = document.createElement('div');
      midFrac.className = 'reduce-frac';
    
      const midNumRow = document.createElement('div'); midNumRow.className = 'reduce-num';
      const midDenRow = document.createElement('div'); midDenRow.className = 'reduce-den';
    
      function addLockedPrime(rowEl, p, exp) {
        if (rowEl.children.length > 0) {
          const times = document.createElement('span');
          times.className = 'reduce-times';
          times.textContent = '×';
          rowEl.appendChild(times);
        }
        const term = document.createElement('span');
        term.className = 'exp-term';
    
        const baseSpan = document.createElement('span');
        baseSpan.textContent = String(p);
        term.appendChild(baseSpan);
    
        const sup = document.createElement('span');
        sup.className = 'exp-sup';
    
        const box = document.createElement('span');
        box.className = 'expo-box';
        box.textContent = String(exp);
        sup.appendChild(box);
    
        term.appendChild(sup);
        rowEl.appendChild(term);
      }
    
      // Build non-interactive numerator/denominator from original exponents
      primesUnion.forEach(p => addLockedPrime(midNumRow, p, fa.get(p) || 0));
      primesUnion.forEach(p => addLockedPrime(midDenRow, p, fb.get(p) || 0));
    
      // bar for mid fraction
      const midBar = document.createElement('div');
      midBar.style.height = '2px';
      midBar.style.width = '100%';
      midBar.style.background = '#1a1a4b';
      midBar.style.margin = '2px 0';
    
      midFrac.appendChild(midNumRow);
      midFrac.appendChild(midBar);
      midFrac.appendChild(midDenRow);
    
      // "=" between mid and interactive
      const eqMid = document.createElement('span');
      eqMid.className = 'reduce-equals';
      eqMid.textContent = '=';
    
      // ---------- Interactive prime-factor fraction with inputs ----------
      const fracBlock = document.createElement('div');
      fracBlock.className = 'reduce-frac';
    
      const numRow = document.createElement('div'); numRow.className = 'reduce-num';
      const denRow = document.createElement('div'); denRow.className = 'reduce-den';
    
      // Track correctness
      const correctNum = new Map();
      const correctDen = new Map();
      let finalShown = false;
    
      function maybeShowFinal() {
        if (finalShown) return;
        // Check all primes satisfied in both rows
        for (const p of primesUnion) {
          if (correctNum.get(p) !== true) return;
          if (correctDen.get(p) !== true) return;
        }
        // All good -> show "= reduced"
        finalShown = true;
        const g = computeGCDFromMaps(fa, fb); // helper below
        const aReduced = Math.trunc(aVal / g);
        const bReduced = Math.trunc(bVal / g);
    
        const eq2 = document.createElement('span');
        eq2.className = 'reduce-equals';
        eq2.textContent = '=';
    
        const rightFrac = document.createElement('span');
        rightFrac.textContent = `\\(\\dfrac{${aReduced}}{${bReduced}}\\)`;
    
        wrap.appendChild(eq2);
        wrap.appendChild(rightFrac);
    
        if (window.MathJax?.typeset) MathJax.typeset([wrap]);
        if (!stage4Started) {
          stage4Started = true;
          maybeRenderCommonDenominatorStage(aVal, bVal, fa, fb, primesUnion);
        }
      }
    
      // Build interactive rows like Stage 2 (targets a-g, b-g)
      function addPrimeWithInput(rowEl, p, targetMap, setCorrectMap) {
        if (rowEl.children.length > 0) {
          const times = document.createElement('span');
          times.className = 'reduce-times';
          times.textContent = '×';
          rowEl.appendChild(times);
        }
    
        const term = document.createElement('span');
        term.className = 'exp-term';
    
        const baseSpan = document.createElement('span');
        baseSpan.textContent = String(p);
        term.appendChild(baseSpan);
    
        const sup = document.createElement('span');
        sup.className = 'exp-sup';
    
        const target = targetMap.get(p) || 0;
    
        const input = document.createElement('input');
        input.type = 'number';
        input.className = 'exp-input';
        input.min = '0'; input.step = '1'; input.placeholder = '…';
    
        input.addEventListener('change', () => {
          const val = Number(input.value);
          if (!Number.isInteger(val) || val < 0) return;
          if (val !== target) return;
    
          const box = document.createElement('span');
          box.className = 'expo-box'; // neutral color for stage 3
          box.textContent = String(target);
          sup.replaceChild(box, input);
    
          setCorrectMap(p, true);
          maybeShowFinal();
        });
    
        sup.appendChild(input);
        term.appendChild(sup);
        rowEl.appendChild(term);
      }
    
      primesUnion.forEach(p => addPrimeWithInput(numRow, p, targetNum, (q, ok) => correctNum.set(q, ok)));
      primesUnion.forEach(p => addPrimeWithInput(denRow, p, targetDen, (q, ok) => correctDen.set(q, ok)));
    
      // bar for interactive fraction
      const bar = document.createElement('div');
      bar.style.height = '2px';
      bar.style.width = '100%';
      bar.style.background = '#1a1a4b';
      bar.style.margin = '2px 0';
    
      fracBlock.appendChild(numRow);
      fracBlock.appendChild(bar);
      fracBlock.appendChild(denRow);
    
      // Wrap the whole line:  a/b  =  [mid fraction]  =  [interactive fraction]  (= final)
      const wrap = document.createElement('div');
      wrap.className = 'reduce-wrap';
      wrap.appendChild(leftFrac);
      wrap.appendChild(eq1);
      wrap.appendChild(midFrac);
      wrap.appendChild(eqMid);
      wrap.appendChild(fracBlock);
      box3.appendChild(wrap);
    
      if (window.MathJax?.typeset) MathJax.typeset([wrap]);
    }

    
    // helper to compute gcd(a,b) from factor maps
    function computeGCDFromMaps(fa, fb) {
      let g = 1;
      const keys = new Set([...fa.keys(), ...fb.keys()]);
      keys.forEach(p => {
        const ea = fa.get(p) || 0, eb = fb.get(p) || 0;
        const e = Math.min(ea, eb);
        if (e > 0) g *= p ** e;
      });
      return g;
    }


    function maybeRenderCommonDenominatorStage(aVal, bVal, fa, fb, primesUnion) {
      // Build LCM exponents (max per prime)
      const lcmExp = new Map();
      primesUnion.forEach(p => {
        lcmExp.set(p, Math.max(fa.get(p) || 0, fb.get(p) || 0));
      });
    
      // Simple factor map for tiny integers (1..10) used in numerators d and e
      function factorMapSmall(n) {
        const m = new Map();
        let x = n;
        for (let p = 2; p * p <= x; p++) {
          while (x % p === 0) { m.set(p, (m.get(p) || 0) + 1); x = Math.trunc(x / p); }
        }
        if (x > 1) m.set(x, (m.get(x) || 0) + 1);
        return m;
      }
    
      // UI: question text
      const q4 = document.createElement('p');
      q4.textContent = 'Add the following 2 fractions, by giving them a common denominator.  To do this, turn the denominator into the lcm, by adding the same number to both the top and bottom exponents.';
      q4.style.textAlign = 'center';
      q4.style.fontWeight = 'bold';
      activityBox.parentElement.appendChild(q4);
    
      // Container
      const box4 = document.createElement('div');
      box4.className = 'activity-box-medish';
      box4.id = 'common-denominator-activity';
      box4.style.marginTop = '10px';
      activityBox.parentElement.appendChild(box4);
    
      // Helpers reused from Stage 3 styles/classes:
      function mkLockedTermRow(primeToExp) {
        const numRow = document.createElement('div'); numRow.className = 'reduce-num';
        const denRow = document.createElement('div'); denRow.className = 'reduce-den';
    
        function addLockedPrime(rowEl, p, exp) {
          if (rowEl.children.length > 0) {
            const times = document.createElement('span');
            times.className = 'reduce-times';
            times.textContent = '×';
            rowEl.appendChild(times);
          }
          const term = document.createElement('span');
          term.className = 'exp-term';
    
          const baseSpan = document.createElement('span');
          baseSpan.textContent = String(p);
          term.appendChild(baseSpan);
    
          const sup = document.createElement('span');
          sup.className = 'exp-sup';
    
          const box = document.createElement('span');
          box.className = 'expo-box';
          box.textContent = String(exp);
          sup.appendChild(box);
    
          term.appendChild(sup);
          rowEl.appendChild(term);
        }
    
        return { numRow, denRow, addLockedPrime };
      }
    
      function mkInteractiveTermRow(targetNumMap, targetDenMap, onRowSolved) {
        const numRow = document.createElement('div'); numRow.className = 'reduce-num';
        const denRow = document.createElement('div'); denRow.className = 'reduce-den';
    
        const correctNum = new Map();
        const correctDen = new Map();
    
        function checkSolved() {
          for (const p of primesUnion) {
            if (correctNum.get(p) !== true) return;
            if (correctDen.get(p) !== true) return;
          }
          onRowSolved?.();
        }
    
        function addPrimeWithInput(rowEl, p, target, setCorrectMap) {
          if (rowEl.children.length > 0) {
            const times = document.createElement('span');
            times.className = 'reduce-times';
            times.textContent = '×';
            rowEl.appendChild(times);
          }
    
          const term = document.createElement('span');
          term.className = 'exp-term';
    
          const baseSpan = document.createElement('span');
          baseSpan.textContent = String(p);
          term.appendChild(baseSpan);
    
          const sup = document.createElement('span');
          sup.className = 'exp-sup';
    
          const input = document.createElement('input');
          input.type = 'number';
          input.className = 'exp-input';
          input.min = '0'; input.step = '1'; input.placeholder = '…';
    
          input.addEventListener('change', () => {
            const val = Number(input.value);
            if (!Number.isInteger(val) || val < 0) return;
            if (val !== (target.get(p) || 0)) return;
    
            const box = document.createElement('span');
            box.className = 'expo-box';
            box.textContent = String(val);
            sup.replaceChild(box, input);
    
            setCorrectMap(p, true);
            checkSolved();
          });
    
          sup.appendChild(input);
          term.appendChild(sup);
          rowEl.appendChild(term);
        }
    
        primesUnion.forEach(p => addPrimeWithInput(numRow, p, targetNumMap, (q, ok) => { correctNum.set(q, ok); }));
        primesUnion.forEach(p => addPrimeWithInput(denRow, p, targetDenMap, (q, ok) => { correctDen.set(q, ok); }));
    
        return { numRow, denRow };
      }
    
      // Build one row like Stage 3 (left MathJax fraction =, mid locked fraction =, right interactive fraction)
      function buildRow(numerVal, denMap, rowLabelLatex) {
        const wrap = document.createElement('div');
        wrap.className = 'reduce-wrap';
    
        const leftFrac = document.createElement('span');  // larger via CSS you already added
        leftFrac.textContent = rowLabelLatex;
    
        const eq1 = document.createElement('span');
        eq1.className = 'reduce-equals';
        eq1.textContent = '=';
    
        // Non-interactive middle: locked decomposition of (numerVal)/(denominator)
        const numerMap = factorMapSmall(numerVal);
        // union is still primesUnion; show zeros where needed
        const midBlock = document.createElement('div');
        midBlock.className = 'reduce-frac';
        const midTop = document.createElement('div'); midTop.className = 'reduce-num';
        const midBot = document.createElement('div'); midBot.className = 'reduce-den';
    
        primesUnion.forEach(p => {
          // numerator fixed
          if (midTop.children.length > 0) {
            const t = document.createElement('span'); t.className = 'reduce-times'; t.textContent = '×'; midTop.appendChild(t);
          }
          const term = document.createElement('span'); term.className = 'exp-term';
          const base = document.createElement('span'); base.textContent = String(p); term.appendChild(base);
          const sup = document.createElement('span'); sup.className = 'exp-sup';
          const box = document.createElement('span'); box.className = 'expo-box'; box.textContent = String(numerMap.get(p) || 0);
          sup.appendChild(box); term.appendChild(sup); midTop.appendChild(term);
        });
    
        primesUnion.forEach(p => {
          // denominator fixed from denMap
          if (midBot.children.length > 0) {
            const t = document.createElement('span'); t.className = 'reduce-times'; t.textContent = '×'; midBot.appendChild(t);
          }
          const term = document.createElement('span'); term.className = 'exp-term';
          const base = document.createElement('span'); base.textContent = String(p); term.appendChild(base);
          const sup = document.createElement('span'); sup.className = 'exp-sup';
          const box = document.createElement('span'); box.className = 'expo-box'; box.textContent = String(denMap.get(p) || 0);
          sup.appendChild(box); term.appendChild(sup); midBot.appendChild(term);
        });
    
        const midBar = document.createElement('div');
        midBar.style.height = '2px'; midBar.style.width = '100%';
        midBar.style.background = '#1a1a4b'; midBar.style.margin = '2px 0';
    
        midBlock.appendChild(midTop);
        midBlock.appendChild(midBar);
        midBlock.appendChild(midBot);
    
        const eq2 = document.createElement('span');
        eq2.className = 'reduce-equals';
        eq2.textContent = '=';
    
        // Interactive right side targets:
        // denominator -> lcmExp
        // numerator -> (numerMap + (lcmExp - denMap)) per prime
        const targetDen = new Map();
        const targetNum = new Map();
        primesUnion.forEach(p => {
          const l = lcmExp.get(p) || 0;
          const d = denMap.get(p) || 0;
          const delta = l - d;
          targetDen.set(p, l);
          targetNum.set(p, (numerMap.get(p) || 0) + delta);
        });
    
        const interBlock = document.createElement('div');
        interBlock.className = 'reduce-frac';
        const interTop = document.createElement('div'); interTop.className = 'reduce-num';
        const interBot = document.createElement('div'); interBot.className = 'reduce-den';
    
        mkInteractiveTermRow(targetNum, targetDen).numRow.childNodes; // just to ensure fn is parsed before call
        const interRows = mkInteractiveTermRow(targetNum, targetDen, null);
        interRows.numRow.childNodes; // noop
    
        // Fill interactive rows with inputs:
        // (mkInteractiveTermRow already created rows with inputs, but we need to append those rows)
        interBlock.appendChild(interRows.numRow);
        const bar2 = document.createElement('div');
        bar2.style.height = '2px'; bar2.style.width = '100%';
        bar2.style.background = '#1a1a4b'; bar2.style.margin = '2px 0';
        interBlock.appendChild(bar2);
        interBlock.appendChild(interRows.denRow);
    
        // Assemble row
        wrap.appendChild(leftFrac);
        wrap.appendChild(eq1);
        wrap.appendChild(midBlock);
        wrap.appendChild(eq2);
        wrap.appendChild(interBlock);
    
        box4.appendChild(wrap);
    
        if (window.MathJax?.typeset) MathJax.typeset([wrap]);
      }
    
      // Random small numerators d/e
      const d = Math.floor(Math.random() * 10) + 1;
      const e = Math.floor(Math.random() * 10) + 1;
    
      // Row 1: d/a
      buildRow(d, fa, `\\(\\dfrac{${d}}{${aVal}}\\)`);
      // Row 2: e/b
      buildRow(e, fb, `\\(\\dfrac{${e}}{${bVal}}\\)`);
    }


    
    // Called when both trees are fully factored; renders inputs + gcd/lcm shells
    function maybeRenderExponentStage(aVal, bVal) {
      if (activityBox.querySelectorAll('.leaf-controls').length > 0) return;
    
      const fa = factorMap(aVal);
      const fb = factorMap(bVal);
      const primesUnion = Array.from(new Set([...fa.keys(), ...fb.keys()])).sort((x, y) => x - y);
      let stage3Started = false; // ensure we only render stage 3 once
    
      // Insert prompt
      const q2 = document.createElement('p');
      q2.textContent = 'Fill in the exponents in the prime factorizations.  Observe the gcd takes the minimums of the exponents, and the lcm takes the maximums.';
      activityBox.parentElement.appendChild(q2);
      q2.style.textAlign = 'center';
      q2.style.fontWeight = 'bold';
    
      // SECOND activity: short box, two rows
      const box2 = document.createElement('div');
      box2.className = 'activity-box-short';
      box2.id = 'exponent-activity';
      box2.style.marginTop = '10px';
      activityBox.parentElement.appendChild(box2);
    
      // state: track correct entries per base for a and b
      const filledA = new Map(); // prime -> exponent (once correct)
      const filledB = new Map();
    
      // ---------- left interactive row builders ----------
      const makeInteractiveRow = (label, fmSelf, fmOther, onFilled) => {
        const row = document.createElement('div');
        row.className = 'exp-row';
        const lbl = document.createElement('span');
        lbl.style.fontWeight = '700';
        lbl.textContent = `${label} =`;
        row.appendChild(lbl);
    
        primesUnion.forEach((p, idx) => {
          if (idx > 0) {
            const times = document.createElement('span');
            times.className = 'exp-times';
            times.textContent = '×';
            row.appendChild(times);
          }
    
          const term = document.createElement('span');
          term.className = 'exp-term';
    
          const baseSpan = document.createElement('span');
          baseSpan.textContent = p.toString();
          term.appendChild(baseSpan);
    
          const sup = document.createElement('span');
          sup.className = 'exp-sup';
    
          const correct = fmSelf.get(p) || 0;
    
          const input = document.createElement('input');
          input.type = 'number';
          input.className = 'exp-input';
          input.min = '0'; input.step = '1'; input.placeholder = '…';
    
          input.addEventListener('change', () => {
            const val = Number(input.value);
            if (!Number.isInteger(val) || val < 0) return;
            if (val !== correct) return;
    
            // replace with colored box (min/max/equal relative to the OTHER number)
            const other = fmOther.get(p) || 0;
            const box = document.createElement('span');
            box.className = 'expo-box';
            if (correct === other) box.classList.add('equal');
            else if (correct < other) box.classList.add('min');
            else box.classList.add('max');
            box.textContent = String(correct);
            sup.replaceChild(box, input);
    
            // record filled and notify
            onFilled(p, correct);
          });
    
          sup.appendChild(input);
          term.appendChild(sup);
          row.appendChild(term);
        });
    
        return row;
      };
    
      // ---------- right result rows ----------
      // Per your earlier spec (note this intentionally swaps the usual math convention):
      // - gcd row shows the GREEN MAX when both exponents entered
      // - lcm row shows the RED MIN when both exponents entered
      const gcdRow = buildResultRow('gcd(a, b)', primesUnion);
      const lcmRow = buildResultRow('lcm(a, b)', primesUnion);
    
      // notify helpers: when a prime is filled on both sides, populate result
      const tryPopulateForPrime = (p) => {
        if (!filledA.has(p) || !filledB.has(p)) return;
        const aExp = filledA.get(p), bExp = filledB.get(p);
      
        // gcd side: RED MIN
        const gSup = gcdRow.querySelector(`.exp-sup[data-prime="${p}"]`);
        if (gSup && !gSup.firstChild) {
          const gBox = document.createElement('span');
          gBox.className = 'expo-box min';
          gBox.textContent = String(Math.min(aExp, bExp));
          gSup.appendChild(gBox);
        }
      
        // lcm side: GREEN MAX
        const lSup = lcmRow.querySelector(`.exp-sup[data-prime="${p}"]`);
        if (lSup && !lSup.firstChild) {
          const lBox = document.createElement('span');
          lBox.className = 'expo-box max';
          lBox.textContent = String(Math.max(aExp, bExp));
          lSup.appendChild(lBox);
        }

        // If both rows have all primes filled, start stage 3 once
        if (!stage3Started &&
            filledA.size === primesUnion.length &&
            filledB.size === primesUnion.length) {
          stage3Started = true;
          maybeRenderReductionStage(aVal, bVal, fa, fb, primesUnion);
        }

      };

    
      const rowA = makeInteractiveRow('a', fa, fb, (p, e) => { filledA.set(p, e); tryPopulateForPrime(p); });
      const rowB = makeInteractiveRow('b', fb, fa, (p, e) => { filledB.set(p, e); tryPopulateForPrime(p); });
    
      // --- New arrangement ---
      // Row 1: a (left) | b (right)
      const lineTop = document.createElement('div');   lineTop.className = 'exp-line';
      lineTop.appendChild(rowA);
      lineTop.appendChild(rowB);
    
      // Row 2: gcd (left) | lcm (right)
      const lineBottom = document.createElement('div'); lineBottom.className = 'exp-line';
      lineBottom.appendChild(gcdRow);
      lineBottom.appendChild(lcmRow);
    
      // add to box
      box2.appendChild(lineTop);
      box2.appendChild(lineBottom);
    
      // keep the second row a bit lower
      lineBottom.style.marginTop = '40px';
    }




    

    
  startBtn.addEventListener('click', () => {

    const feedback = document.getElementById('feedbackText');
    feedback.textContent = '';


    let question = `Find the prime factorizations of `;

    let primes = [13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
    a2 = 20;
    b2 = 20;
  
    // Randomly determine prime powers
    while ((a2 + a3 + a5 + a7 + a11 + an) > 7 || (a2 + a3 + a5 + a7 + a11 + an) < 4) {
      a2 = Math.floor(Math.random() * 4.75);
      a3 = Math.floor(Math.random() * 3.5);
      a5 = Math.floor(Math.random() * 2.75);
      a7 = Math.floor(Math.random() * 1.75);
      a11 = Math.floor(Math.random() * 1.5);
      an = Math.floor(Math.random() * 1.5);
    }

    antype = primes[Math.floor(Math.random() * 10)];

    a = 2**a2 * 3**a3 * 5**a5 * 7**a7 * 11**a11 * antype**an;
    anum = a2 + a3 + a5 + a7 + a11 + an;
    
    while ((b2 + b3 + b5 + b7 + b11 + bn) > 7 || (b2 + b3 + b5 + b7 + b11 + bn) < 4) {
      b2 = Math.floor(Math.random() * 4.75);
      b3 = Math.floor(Math.random() * 3.5);
      b5 = Math.floor(Math.random() * 2.75);
      b7 = Math.floor(Math.random() * 1.75);
      b11 = Math.floor(Math.random() * 1.5);
      if (an == 1) {
        bn = 0;
      } else {
        bn = Math.floor(Math.random() * 1.5);
      }
    }

    bntype = primes[Math.floor(Math.random() * 10)];

    b = 2**b2 * 3**b3 * 5**b5 * 7**b7 * 11**b11 * bntype**bn;
    bnum = b2 + b3 + b5 + b7 + b11 + bn;
  
    console.log(`a powers: ${a2}, ${a3}, ${a5}, ${a7}, ${a11}, ${an} and a mystery prime: ${antype}`);
    console.log(`b powers: ${b2}, ${b3}, ${b5}, ${b7}, ${b11}, ${bn} and b mystery prime: ${bntype}`);

    // Display the question
    questionText.textContent = question + `the numbers ${a} and ${b}.  Input divisors of each number to break them down into primes.`;

    MathJax.typeset([questionText]);

    // Remove a prior exponent stage (if user restarts)
    const oldQ2 = document.querySelector('#exponent-activity')?.previousElementSibling;
    if (document.getElementById('exponent-activity')) {
      document.getElementById('exponent-activity').remove();
      if (oldQ2 && oldQ2.tagName === 'P' && oldQ2.textContent.startsWith('Fill in the exponents')) {
        oldQ2.remove();
      }
    }

    // Clear the activity box
    activityBox.innerHTML = '';
    
    // Enable compact mode for side-by-side
    activityBox.classList.add('compact');
    
    // Create a canvas
    const canvas = document.createElement('canvas');
    canvas.width = 1300;
    canvas.height = 750;
    activityBox.appendChild(canvas);
    
    const ctx = canvas.getContext('2d');
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 4;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Layout constants for side-by-side trees
    const halfWidth = 650;
    const boxH = 60;         // compact box height
    const topY = 12;         // a bit tighter top padding
    
    // --- LEFT: a ---
    const aCenterX = 325;    // center of left 0..650
    createNumberLeaf({
      value: a,
      centerX: aCenterX,
      topY,
      totalAnum: anum,
      segmentLeft: 0,
      segmentRight: halfWidth,
      ctx,
      totalWidth: halfWidth,
      boxHeight: boxH
    });
    
    // --- RIGHT: b ---
    const bCenterX = 650 + 325; // 975, center of right 650..1300
    createNumberLeaf({
      value: b,
      centerX: bCenterX,
      topY,
      totalAnum: bnum,
      segmentLeft: halfWidth,
      segmentRight: 1300,
      ctx,
      totalWidth: halfWidth,
      boxHeight: boxH
    });



  });

    const feedbackText = document.getElementById('feedbackText');
    
  </script>

  <audio id="click-sound" src="button.mp3" preload="auto"></audio>
  <audio id="set-sound" src="set2.mp3" preload="auto"></audio>
  
</body>
</html>
