
<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Personal website of Ben Fraser, with math education activities for students and teachers.">
  <meta charset="UTF-8" />
  <title>Shape Sort Activity</title>
  <link rel="stylesheet" href="/style.css" />

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>Shape Sort Activity</h1>
    <div id="nav-placeholder"></div>
      <script>
fetch("/nav.html")
  .then(response => response.text())
  .then(html => {
    document.getElementById("nav-placeholder").innerHTML = html;

    const currentPath = window.location.pathname.replace(/\/index\.html$/, "/");
    const navLinks = document.querySelectorAll("#nav-placeholder a");
    navLinks.forEach(link => {
      const linkPath = new URL(link.href).pathname.replace(/\/index\.html$/, "/");
      if (linkPath === currentPath) {
        link.classList.add("active");
      }
    });

    const s = document.createElement("script");
    s.src = "/mascot.js";
    s.defer = true;
    document.body.appendChild(s); 
  })
  .catch(err => {
    console.error("Failed to load nav:", err);
  });
</script>
  </header>
  <main>

    <div class="button-container">
      <button id="start-btn" class="rubber-button">Start!</button>
    </div>
    
    <p id="question-text"></p>


    <div class="activity-box" id="my-activity">

    </div>
    
    <div class="button-container">
      <div id="feedbackText" class="center-feedback"></div>
    </div>





  </main>

  <script>

    
    let m0 = 0;
    let currentDragged = null;




    const startBtn = document.getElementById('start-btn');
    const questionText = document.getElementById('question-text');
    const activityBox = document.getElementById('my-activity');


        function addTextToActivityBox(text, x, y, fontSize = 28) {
      const txt = document.createElement('div');
      txt.classList.add('activity-text');
      txt.textContent = text;
      txt.style.left = `${x}px`;
      txt.style.top = `${y}px`;
      txt.style.fontSize = `${fontSize}px`;
      activityBox.appendChild(txt);
    }

    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    
    function createDraggableShapeToken(num, x, y, { shape, color, sizeClass = "" }) {
      const token = document.createElement('div');
      token.className = 'shape-token draggable-exponent';
      if (sizeClass) token.classList.add(sizeClass);
      token.style.left = `${x}px`;
      token.style.top  = `${y}px`;
    
      // store attributes for set-membership checks
      token.dataset.shape = shape;                 // 'triangle' | 'square'
      token.dataset.color = color;                 // 'green' | 'red'
      token.dataset.size  = sizeClass || 'default';// 'large' | 'small' | 'default' (2-set)
    
      const body = document.createElement('div');
      body.className = `shape-body ${shape}`;
      body.style.background = color;
      token.appendChild(body);
    
      const label = document.createElement('span');
      label.className = 'shape-label';
      label.textContent = String(num);
      body.appendChild(label);
    
      activityBox.appendChild(token);
      makeExponentDraggable(token);
      return token;
    }
    
    function makeExponentDraggable(elem) {
      elem.draggable = true;
    
      elem.addEventListener('dragstart', e => {
        currentDragged = elem;                            // remember which one
        e.dataTransfer.setData('text/plain', elem.textContent);
        setTimeout(() => elem.style.visibility = 'hidden', 0);
      });
    
      elem.addEventListener('dragend', () => {
        elem.style.visibility = 'visible';
        currentDragged = null;
      });
    }




    function createFixedExponentBox(text, x, y, boxSize = 80, fontSize = 28) {
      const box = document.createElement('div');
      box.classList.add('exponent-box');
      box.style.left = `${x}px`;
      box.style.top = `${y}px`;
      box.style.width = `${boxSize}px`;
      box.style.height = `${boxSize}px`;
      box.style.fontSize = `${fontSize}px`;
      box.textContent = text;
      activityBox.appendChild(box);
      return box;
    }
    
    function createDraggableExponentBox(text, x, y, boxSize = 80, fontSize = 28) {
      const box = document.createElement('div');
      box.classList.add('exponent-box', 'draggable-exponent');
      box.style.left = `${x}px`;
      box.style.top = `${y}px`;
      box.style.width = `${boxSize}px`;
      box.style.height = `${boxSize}px`;
      box.style.fontSize = `${fontSize}px`;
      box.textContent = text;
      activityBox.appendChild(box);
      makeExponentDraggable(box);
      return box;
    }
    
    function createExponentSlot(x, y, boxSize = 80, fontSize = 28) {
      const slot = document.createElement('div');
      slot.classList.add('exponent-box', 'exponent-slot');
      slot.style.left = `${x}px`;
      slot.style.top = `${y}px`;
      slot.style.width = `${boxSize}px`;
      slot.style.height = `${boxSize}px`;
      slot.style.fontSize = `${fontSize}px`;
      activityBox.appendChild(slot);
      setupDropTarget(slot);
      return slot;
    }

    
    function setupDropTarget(slot) {
      slot.addEventListener('dragover', e => {
        e.preventDefault();
        slot.classList.add('valid-hover');
      });
    
      slot.addEventListener('dragleave', () => {
        slot.classList.remove('valid-hover');
      });
    
      slot.addEventListener('drop', e => {
        e.preventDefault();
        slot.classList.remove('valid-hover');
        const droppedText = e.dataTransfer.getData('text/plain');
        slot.textContent = droppedText;
    
        // Play sound when an exponent is dropped
        const sound = document.getElementById('set-sound');
        if (sound) {
          sound.currentTime = 0; // rewind to start in case it's still playing
          sound.play();
        }
      });
    }


    // Create or reuse a single popup element in the activity box
    function ensureHintPopup() {
      let el = activityBox.querySelector('.hint-popup');
      if (!el) {
        el = document.createElement('div');
        el.className = 'hint-popup hidden';
        el.innerHTML = `
          <div class="hint-close" aria-label="Close">&times;</div>
          <div class="hint-title"></div>
          <div class="hint-desc"></div>
        `;
        activityBox.appendChild(el);
        el.querySelector('.hint-close').addEventListener('click', () => hideHintPopup());
      }
      return el;
    }
    
    function hideHintPopup() {
      const el = activityBox.querySelector('.hint-popup');
      if (el) el.classList.add('hidden');
    }
    
    function showHintAt(latex, desc, clientX, clientY) {
      const el = ensureHintPopup();
      // Fill content
      el.querySelector('.hint-title').textContent = '';  // clear before MathJax
      el.querySelector('.hint-desc').textContent  = desc;
      el.classList.remove('hidden');
    
      // Render LaTeX into the title area
      el.querySelector('.hint-title').innerHTML = `\\(${latex}\\)`;
      if (window.MathJax && MathJax.typesetPromise) {
        MathJax.typesetPromise([el]);
      }
    
      // Position near the click, but keep inside the activity box
      const box = activityBox.getBoundingClientRect();
      let left = clientX - box.left + 12;
      let top  = clientY - box.top  + 12;
      el.style.left = `${left}px`;
      el.style.top  = `${top}px`;
    
      // After itâ€™s in the layout, clamp if it overflows
      const w = el.offsetWidth, h = el.offsetHeight;
      const maxLeft = box.width  - w - 8;
      const maxTop  = box.height - h - 8;
      if (left > maxLeft) el.style.left = `${Math.max(8, maxLeft)}px`;
      if (top  > maxTop ) el.style.top  = `${Math.max(8, maxTop)}px`;
    }





    
  startBtn.addEventListener('click', () => {

      const feedback = document.getElementById('feedbackText');
      feedback.textContent = '';

      
      m0 = 0;

    
      // Randomly determine unknown quantities.  Variables have a corresponding boolean
      m0 = Math.random();
      
      if (m0 < 0.34) {
        // Display the question
        questionText.textContent = `Sort the shapes!  Let U be the universal set, G the set of green shapes, and T the set of triangles.`;
      } else {
        // Display the question
        questionText.textContent = `Sort the shapes!  Let U be the universal set, G the set of green shapes, T the set of triangles, and
        L the set of large shapes.`;
      }

      
      // Clear the activity box
      activityBox.innerHTML = '';
      
      // Create a canvas
      const canvas = document.createElement('canvas');
      canvas.width = 1300;
      canvas.height = 650;
      activityBox.appendChild(canvas);
      
      const ctx = canvas.getContext('2d');
      
      // Draw the universal set rectangle
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 4;
      ctx.strokeRect(200, 30, 900, 500);

      if (m0 < 0.34) {
        // Draw circle A
        ctx.beginPath();
        ctx.arc(525, 275, 180, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Draw circle B
        ctx.beginPath();
        ctx.arc(775, 275, 180, 0, 2 * Math.PI);
        ctx.stroke();

        addTextToActivityBox('G', 335, 370, 80);
        addTextToActivityBox('T', 915, 370, 80);
        addTextToActivityBox('U', 1110, 20, 80);
      } else {
        // Draw circle A
        ctx.beginPath();
        ctx.arc(550, 200, 150, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Draw circle B
        ctx.beginPath();
        ctx.arc(750, 200, 150, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Draw circle C
        ctx.beginPath();
        ctx.arc(650, 350, 150, 0, 2 * Math.PI);
        ctx.stroke();
  
        addTextToActivityBox('G', 350, 40, 80);
        addTextToActivityBox('T', 900, 40, 80);
        addTextToActivityBox('L', 755, 415, 80);
        addTextToActivityBox('U', 1110, 20, 80);
      }

      // Build 15 draggable shape tokens
      const isTwoSet = (m0 < 0.34);
      const COLORS   = ['green', 'red'];
      const SHAPES   = ['square', 'triangle'];
      
      for (let i = 0; i < 15; i++) {
        const shape = randomChoice(SHAPES);
        const color = randomChoice(COLORS);
      
        // 3-set adds size variety; 2-set uses the default size
        const sizeClass = isTwoSet ? "" : randomChoice(['small','large']);
      
        // Lay them out along the bottom row (like before)
        const x = 40 + (i * 80);
        const y = 560;
      
        createDraggableShapeToken(i + 1, x, y, { shape, color, sizeClass });
      }



      if (m0 < 0.34) {
        const geom2 = {
          U: { x: 200, y: 30, w: 900, h: 500 },
          A: { x: 525, y: 275, r: 180 },
          B: { x: 775, y: 275, r: 180 }
        };

        function drawBase2() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 4;
          ctx.strokeRect(geom2.U.x, geom2.U.y, geom2.U.w, geom2.U.h);
          ctx.beginPath(); ctx.arc(geom2.A.x, geom2.A.y, geom2.A.r, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath(); ctx.arc(geom2.B.x, geom2.B.y, geom2.B.r, 0, Math.PI * 2); ctx.stroke();
        }

        function drawURectPath() {
          ctx.beginPath();
          ctx.rect(geom2.U.x, geom2.U.y, geom2.U.w, geom2.U.h);
        }
        function drawCirclePath(c) {
          ctx.beginPath();
          ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
        }

        function getRegion2(x, y) {
          const inRect = (x >= geom2.U.x && x <= geom2.U.x + geom2.U.w && y >= geom2.U.y && y <= geom2.U.y + geom2.U.h);
          if (!inRect) return null;
          const inA = Math.hypot(x - geom2.A.x, y - geom2.A.y) <= geom2.A.r;
          const inB = Math.hypot(x - geom2.B.x, y - geom2.B.y) <= geom2.B.r;
          if (!inA && !inB) return 'Uminus';
          if (inA && !inB) return 'Aonly';
          if (!inA && inB) return 'Bonly';
          if (inA && inB) return 'AcapB';
          return null;
        }

        const regionInfo2 = {
          Uminus: { latex: 'U \\setminus (G\\cup T)', desc: 'Shapes which are neither green nor triangles.' },
          Aonly:  { latex: 'G \\setminus T',         desc: 'Shapes which are green but are not triangles.' },
          Bonly:  { latex: 'T \\setminus G',         desc: 'Shapes which are triangles but are not green.' },
          AcapB:  { latex: 'G \\cap T',              desc: 'Shapes which are green triangles.' }
        };
        
        // Show hint when user clicks a region (ignore during drag)
        canvas.addEventListener('click', (e) => {
          if (draggingExponent) return;
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const r = getRegion2(x, y);
          if (!r || !regionInfo2[r]) { hideHintPopup(); return; }
          const { latex, desc } = regionInfo2[r];
          showHintAt(latex, desc, e.clientX, e.clientY);
        });


        function highlightRegion2(region) {
          // Offscreen layer (create once per canvas if you prefer)
          const layer = document.createElement('canvas');
          layer.width = canvas.width;
          layer.height = canvas.height;
          const t = layer.getContext('2d');
        
          const HIGHLIGHT = 'rgba(0, 200, 0, 0.25)'; // visible tint
          const MASK = '#000';                       // opaque for masking
        
          // Local path helpers that draw into 't' (the offscreen ctx)
          const rectPath = () => { t.beginPath(); t.rect(geom2.U.x, geom2.U.y, geom2.U.w, geom2.U.h); };
          const circlePath = (c) => { t.beginPath(); t.arc(c.x, c.y, c.r, 0, Math.PI * 2); };
        
          // Build the region ONLY on the offscreen layer
          t.clearRect(0, 0, layer.width, layer.height);
          t.globalCompositeOperation = 'source-over';
          switch (region) {
            case 'Uminus':
              rectPath(); t.fillStyle = HIGHLIGHT; t.fill();
              t.globalCompositeOperation = 'destination-out';
              t.fillStyle = MASK; circlePath(geom2.A); t.fill();
              t.fillStyle = MASK; circlePath(geom2.B); t.fill();
              break;
        
            case 'Aonly':
              circlePath(geom2.A); t.fillStyle = HIGHLIGHT; t.fill();
              t.globalCompositeOperation = 'destination-out';
              t.fillStyle = MASK; circlePath(geom2.B); t.fill();
              break;
        
            case 'Bonly':
              circlePath(geom2.B); t.fillStyle = HIGHLIGHT; t.fill();
              t.globalCompositeOperation = 'destination-out';
              t.fillStyle = MASK; circlePath(geom2.A); t.fill();
              break;
        
            case 'AcapB':
              circlePath(geom2.A); t.fillStyle = HIGHLIGHT; t.fill();
              t.globalCompositeOperation = 'destination-in';
              t.fillStyle = MASK; circlePath(geom2.B); t.fill();
              break;
          }
        
          // Paint highlight over the base drawing (doesn't erase strokes)
          ctx.drawImage(layer, 0, 0);
        
          // Re-stroke outlines on top so theyâ€™re fully black (not green-tinted)
          ctx.save();
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 4;
          ctx.strokeRect(geom2.U.x, geom2.U.y, geom2.U.w, geom2.U.h);
          ctx.beginPath(); ctx.arc(geom2.A.x, geom2.A.y, geom2.A.r, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath(); ctx.arc(geom2.B.x, geom2.B.y, geom2.B.r, 0, Math.PI * 2); ctx.stroke();
          ctx.restore();
        }


        function isValid2(token, region) {
          const isGreen    = token.dataset.color === 'green';
          const isTriangle = token.dataset.shape === 'triangle';
          switch (region) {
            case 'Uminus': return !isGreen && !isTriangle;           // neither G nor T
            case 'Aonly':  return  isGreen && !isTriangle;           // G \ T
            case 'Bonly':  return !isGreen &&  isTriangle;           // T \ G
            case 'AcapB':  return  isGreen &&  isTriangle;           // G âˆ© T
            default: return false;
          }
        }
        
        // drop onto canvas where the cursor is (center token under cursor)
        canvas.addEventListener('drop', (e) => {
          if (!draggingExponent) return;
          e.preventDefault();
        
          const canvasRect = canvas.getBoundingClientRect();
          const x = e.clientX - canvasRect.left;
          const y = e.clientY - canvasRect.top;
        
          const region = getRegion2(x, y);
          drawBase2(); // clear highlight
        
          if (region && currentDragged && isValid2(currentDragged, region)) {
            const abRect = activityBox.getBoundingClientRect();
            const left = e.clientX - abRect.left - currentDragged.offsetWidth  / 2;
            const top  = e.clientY - abRect.top  - currentDragged.offsetHeight / 2;
            currentDragged.style.left = `${left}px`;
            currentDragged.style.top  = `${top}px`;
          }
        });




        let draggingExponent = false;
        document.addEventListener('dragstart', (e) => {
          if (e.target && e.target.classList && e.target.classList.contains('draggable-exponent')) {
            draggingExponent = true;
          }
        });
        document.addEventListener('dragend', () => {
          draggingExponent = false;
          drawBase2();
        });

        canvas.addEventListener('dragover', (e) => {
          if (!draggingExponent) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          drawBase2();
          const region = getRegion2(x, y);
          if (region) highlightRegion2(region);
        });

        canvas.addEventListener('dragleave', () => {
          if (!draggingExponent) return;
          drawBase2();
        });
      }
else {
  const geom3 = {
    U: { x: 200, y: 30, w: 900, h: 500 },
    A: { x: 550, y: 200, r: 150 },
    B: { x: 750, y: 200, r: 150 },
    C: { x: 650, y: 350, r: 150 }
  };

  function drawBase3() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 4;
    ctx.strokeRect(geom3.U.x, geom3.U.y, geom3.U.w, geom3.U.h);
    ctx.beginPath(); ctx.arc(geom3.A.x, geom3.A.y, geom3.A.r, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.arc(geom3.B.x, geom3.B.y, geom3.B.r, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.arc(geom3.C.x, geom3.C.y, geom3.C.r, 0, Math.PI * 2); ctx.stroke();
  }

  function drawURectPath3() {
    ctx.beginPath();
    ctx.rect(geom3.U.x, geom3.U.y, geom3.U.w, geom3.U.h);
  }
  function drawCirclePath3(c) {
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
  }

  function getRegion3(x, y) {
    const inRect = (x >= geom3.U.x && x <= geom3.U.x + geom3.U.w && y >= geom3.U.y && y <= geom3.U.y + geom3.U.h);
    if (!inRect) return null;
    const inA = Math.hypot(x - geom3.A.x, y - geom3.A.y) <= geom3.A.r;
    const inB = Math.hypot(x - geom3.B.x, y - geom3.B.y) <= geom3.B.r;
    const inC = Math.hypot(x - geom3.C.x, y - geom3.C.y) <= geom3.C.r;

    if (!inA && !inB && !inC) return 'Uminus';
    if (inA && !inB && !inC) return 'Aonly';
    if (!inA && inB && !inC) return 'Bonly';
    if (!inA && !inB && inC) return 'Conly';
    if (inA && inB && !inC) return 'AcapBonly';
    if (inA && inC && !inB) return 'AcapConly';
    if (inB && inC && !inA) return 'BcapConly';
    if (inA && inB && inC) return 'AcapBcapC';
    return null;
  }

  const regionInfo3 = {
    Uminus:     { latex: 'U \\setminus (G\\cup T\\cup L)', desc: 'Shapes which are not green, not triangles, and not large.' },
    Aonly:      { latex: 'G \\setminus (T\\cup L)',        desc: 'Shapes which are green but are neither triangles nor large.' },
    Bonly:      { latex: 'T \\setminus (G\\cup L)',        desc: 'Shapes which are triangles but are neither green nor large.' },
    Conly:      { latex: 'L \\setminus (G\\cup T)',        desc: 'Shapes which are large but are neither green nor triangles.' },
    AcapBonly:  { latex: '(G \\cap T) \\setminus L',       desc: 'Shapes which are green triangles that are not large.' },
    AcapConly:  { latex: '(G \\cap L) \\setminus T',       desc: 'Shapes which are green and large but are not triangles.' },
    BcapConly:  { latex: '(T \\cap L) \\setminus G',       desc: 'Shapes which are triangles and large but are not green.' },
    AcapBcapC:  { latex: 'G \\cap T \\cap L',              desc: 'Shapes which are green triangles that are large.' }
  };
  
  canvas.addEventListener('click', (e) => {
    if (draggingExponent3) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const r = getRegion3(x, y);
    if (!r || !regionInfo3[r]) { hideHintPopup(); return; }
    const { latex, desc } = regionInfo3[r];
    showHintAt(latex, desc, e.clientX, e.clientY);
  });


  function highlightRegion3(region) {
    const layer = document.createElement('canvas');
    layer.width = canvas.width;
    layer.height = canvas.height;
    const t = layer.getContext('2d');
  
    const HIGHLIGHT = 'rgba(0, 200, 0, 0.25)';
    const MASK = '#000';
  
    const rectPath = () => { t.beginPath(); t.rect(geom3.U.x, geom3.U.y, geom3.U.w, geom3.U.h); };
    const circlePath = (c) => { t.beginPath(); t.arc(c.x, c.y, c.r, 0, Math.PI * 2); };
  
    t.clearRect(0, 0, layer.width, layer.height);
    t.globalCompositeOperation = 'source-over';
  
    switch (region) {
      case 'Uminus':
        rectPath(); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.A); t.fill();
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        break;
  
      case 'Aonly':
        circlePath(geom3.A); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        break;
  
      case 'Bonly':
        circlePath(geom3.B); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.A); t.fill();
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        break;
  
      case 'Conly':
        circlePath(geom3.C); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.A); t.fill();
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        break;
  
      case 'AcapBonly':
        circlePath(geom3.A); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-in';
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        break;
  
      case 'AcapConly':
        circlePath(geom3.A); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-in';
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        break;
  
      case 'BcapConly':
        circlePath(geom3.B); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-in';
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.A); t.fill();
        break;
  
      case 'AcapBcapC':
        circlePath(geom3.A); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-in';
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        t.globalCompositeOperation = 'destination-in';
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        break;
    }
  
    ctx.drawImage(layer, 0, 0);
  
    // Re-stroke outlines on top
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 4;
    ctx.strokeRect(geom3.U.x, geom3.U.y, geom3.U.w, geom3.U.h);
    ctx.beginPath(); ctx.arc(geom3.A.x, geom3.A.y, geom3.A.r, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.arc(geom3.B.x, geom3.B.y, geom3.B.r, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.arc(geom3.C.x, geom3.C.y, geom3.C.r, 0, Math.PI * 2); ctx.stroke();
    ctx.restore();
  }


  function isValid3(token, region) {
    const isGreen    = token.dataset.color === 'green';     // A: G
    const isTriangle = token.dataset.shape === 'triangle';  // B: T
    const isLarge    = token.dataset.size  === 'large';     // C: L
  
    switch (region) {
      case 'Uminus':      return !isGreen && !isTriangle && !isLarge;
      case 'Aonly':       return  isGreen && !isTriangle && !isLarge;
      case 'Bonly':       return !isGreen &&  isTriangle && !isLarge;
      case 'Conly':       return !isGreen && !isTriangle &&  isLarge;
      case 'AcapBonly':   return  isGreen &&  isTriangle && !isLarge;
      case 'AcapConly':   return  isGreen && !isTriangle &&  isLarge;
      case 'BcapConly':   return !isGreen &&  isTriangle &&  isLarge;
      case 'AcapBcapC':   return  isGreen &&  isTriangle &&  isLarge;
      default: return false;
    }
  }
  
  canvas.addEventListener('drop', (e) => {
    if (!draggingExponent3) return;
    e.preventDefault();
  
    const canvasRect = canvas.getBoundingClientRect();
    const x = e.clientX - canvasRect.left;
    const y = e.clientY - canvasRect.top;
  
    const region = getRegion3(x, y);
    drawBase3(); // clear highlight
  
    if (region && currentDragged && isValid3(currentDragged, region)) {
      const abRect = activityBox.getBoundingClientRect();
      const left = e.clientX - abRect.left - currentDragged.offsetWidth  / 2;
      const top  = e.clientY - abRect.top  - currentDragged.offsetHeight / 2;
      currentDragged.style.left = `${left}px`;
      currentDragged.style.top  = `${top}px`;
    }
  });




  let draggingExponent3 = false;
  document.addEventListener('dragstart', (e) => {
    if (e.target && e.target.classList && e.target.classList.contains('draggable-exponent')) {
      draggingExponent3 = true;
    }
  });
  document.addEventListener('dragend', () => {
    draggingExponent3 = false;
    drawBase3();
  });

  canvas.addEventListener('dragover', (e) => {
    if (!draggingExponent3) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    drawBase3();
    const region = getRegion3(x, y);
    if (region) highlightRegion3(region);
  });

  canvas.addEventListener('dragleave', () => {
    if (!draggingExponent3) return;
    drawBase3();
  });
}



      // â€”â€” Guard missing hintArea (keeps placeholder from erroring) â€”â€”
      if (typeof hintArea !== 'undefined' && hintArea) {
        hintIndex = 0;
        hintArea.innerHTML = "";
      }


    });


    const feedbackText = document.getElementById('feedbackText');
    

  activityBox.addEventListener('click', (e) => {
    const inPopup = e.target.closest && e.target.closest('.hint-popup');
    if (!inPopup && e.target !== canvas) hideHintPopup();
  });

    
  </script>

  <audio id="click-sound" src="button.mp3" preload="auto"></audio>
  <audio id="set-sound" src="set2.mp3" preload="auto"></audio>
  
</body>
</html>
