
<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Personal website of Ben Fraser, with math education activities for students and teachers.">
  <meta charset="UTF-8" />
  <title>Shape Sort Activity</title>
  <link rel="stylesheet" href="/style.css" />

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>Shape Sort Activity</h1>
    <div id="nav-placeholder"></div>
      <script>
fetch("/nav.html")
  .then(response => response.text())
  .then(html => {
    document.getElementById("nav-placeholder").innerHTML = html;

    const currentPath = window.location.pathname.replace(/\/index\.html$/, "/");
    const navLinks = document.querySelectorAll("#nav-placeholder a");
    navLinks.forEach(link => {
      const linkPath = new URL(link.href).pathname.replace(/\/index\.html$/, "/");
      if (linkPath === currentPath) {
        link.classList.add("active");
      }
    });

    const s = document.createElement("script");
    s.src = "/mascot.js";
    s.defer = true;
    document.body.appendChild(s); 
  })
  .catch(err => {
    console.error("Failed to load nav:", err);
  });
</script>
  </header>
  <main>

    <p>This is a placeholder activity for a shape-sorting activity.  Hopefully it's ready in time!</p>

    <div class="button-container">
      <button id="start-btn" class="rubber-button">Start!</button>
    </div>
    
    <p id="question-text"></p>


    <div class="activity-box" id="my-activity">

    </div>
    
    <div class="button-container">
      <div id="feedbackText" class="center-feedback"></div>
    </div>





  </main>

  <script>

    
    let m0 = 0;



    const startBtn = document.getElementById('start-btn');
    const questionText = document.getElementById('question-text');
    const activityBox = document.getElementById('my-activity');


        function addTextToActivityBox(text, x, y, fontSize = 28) {
      const txt = document.createElement('div');
      txt.classList.add('activity-text');
      txt.textContent = text;
      txt.style.left = `${x}px`;
      txt.style.top = `${y}px`;
      txt.style.fontSize = `${fontSize}px`;
      activityBox.appendChild(txt);
    }

    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    
    function createDraggableShapeToken(num, x, y, { shape, color, sizeClass = "" }) {
      const token = document.createElement('div');
      token.className = 'shape-token draggable-exponent';
      if (sizeClass) token.classList.add(sizeClass);
      token.style.left = `${x}px`;
      token.style.top  = `${y}px`;
    
      const body = document.createElement('div');
      body.className = `shape-body ${shape}`;
      body.style.background = color;
      token.appendChild(body);
    
      const label = document.createElement('span');
      label.className = 'shape-label';
      label.textContent = String(num);
      body.appendChild(label);
    
      activityBox.appendChild(token);
      makeExponentDraggable(token);  
      return token;
    }



    function createFixedExponentBox(text, x, y, boxSize = 80, fontSize = 28) {
      const box = document.createElement('div');
      box.classList.add('exponent-box');
      box.style.left = `${x}px`;
      box.style.top = `${y}px`;
      box.style.width = `${boxSize}px`;
      box.style.height = `${boxSize}px`;
      box.style.fontSize = `${fontSize}px`;
      box.textContent = text;
      activityBox.appendChild(box);
      return box;
    }
    
    function createDraggableExponentBox(text, x, y, boxSize = 80, fontSize = 28) {
      const box = document.createElement('div');
      box.classList.add('exponent-box', 'draggable-exponent');
      box.style.left = `${x}px`;
      box.style.top = `${y}px`;
      box.style.width = `${boxSize}px`;
      box.style.height = `${boxSize}px`;
      box.style.fontSize = `${fontSize}px`;
      box.textContent = text;
      activityBox.appendChild(box);
      makeExponentDraggable(box);
      return box;
    }
    
    function createExponentSlot(x, y, boxSize = 80, fontSize = 28) {
      const slot = document.createElement('div');
      slot.classList.add('exponent-box', 'exponent-slot');
      slot.style.left = `${x}px`;
      slot.style.top = `${y}px`;
      slot.style.width = `${boxSize}px`;
      slot.style.height = `${boxSize}px`;
      slot.style.fontSize = `${fontSize}px`;
      activityBox.appendChild(slot);
      setupDropTarget(slot);
      return slot;
    }



    function makeExponentDraggable(elem) {
      elem.draggable = true;
    
      elem.addEventListener('dragstart', e => {
        e.dataTransfer.setData('text/plain', elem.textContent);
        setTimeout(() => elem.style.visibility = 'hidden', 0);
      });
    
      elem.addEventListener('dragend', () => {
        elem.style.visibility = 'visible';
      });
    }
    
    function setupDropTarget(slot) {
      slot.addEventListener('dragover', e => {
        e.preventDefault();
        slot.classList.add('valid-hover');
      });
    
      slot.addEventListener('dragleave', () => {
        slot.classList.remove('valid-hover');
      });
    
      slot.addEventListener('drop', e => {
        e.preventDefault();
        slot.classList.remove('valid-hover');
        const droppedText = e.dataTransfer.getData('text/plain');
        slot.textContent = droppedText;
    
        // Play sound when an exponent is dropped
        const sound = document.getElementById('set-sound');
        if (sound) {
          sound.currentTime = 0; // rewind to start in case it's still playing
          sound.play();
        }
      });
    }




    
  startBtn.addEventListener('click', () => {

      const feedback = document.getElementById('feedbackText');
      feedback.textContent = '';

      
      m0 = 0;

    
      // Randomly determine unknown quantities.  Variables have a corresponding boolean
      m0 = Math.random();
      
  
      // Display the question
      questionText.textContent = `Sort the shapes!  Let U be the universal set, G the set of green shapes, T the set of triangles, and
      L the set of large shapes.`;

      
      // Clear the activity box
      activityBox.innerHTML = '';
      
      // Create a canvas
      const canvas = document.createElement('canvas');
      canvas.width = 1300;
      canvas.height = 650;
      activityBox.appendChild(canvas);
      
      const ctx = canvas.getContext('2d');
      
      // Draw the universal set rectangle
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 4;
      ctx.strokeRect(200, 30, 900, 500);

      if (m0 < 0.34) {
        // Draw circle A
        ctx.beginPath();
        ctx.arc(525, 275, 180, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Draw circle B
        ctx.beginPath();
        ctx.arc(775, 275, 180, 0, 2 * Math.PI);
        ctx.stroke();

        addTextToActivityBox('G', 335, 370, 80);
        addTextToActivityBox('T', 915, 370, 80);
        addTextToActivityBox('U', 1110, 20, 80);
      } else {
        // Draw circle A
        ctx.beginPath();
        ctx.arc(550, 200, 150, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Draw circle B
        ctx.beginPath();
        ctx.arc(750, 200, 150, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Draw circle C
        ctx.beginPath();
        ctx.arc(650, 350, 150, 0, 2 * Math.PI);
        ctx.stroke();
  
        addTextToActivityBox('G', 350, 40, 80);
        addTextToActivityBox('T', 900, 40, 80);
        addTextToActivityBox('L', 755, 415, 80);
        addTextToActivityBox('U', 1110, 20, 80);
      }

      // Build 15 draggable shape tokens
      const isTwoSet = (m0 < 0.34);
      const COLORS   = ['green', 'red'];
      const SHAPES   = ['square', 'triangle'];
      
      for (let i = 0; i < 15; i++) {
        const shape = randomChoice(SHAPES);
        const color = randomChoice(COLORS);
      
        // 3-set adds size variety; 2-set uses the default size
        const sizeClass = isTwoSet ? "" : randomChoice(['small','large']);
      
        // Lay them out along the bottom row (like before)
        const x = 40 + (i * 80);
        const y = 560;
      
        createDraggableShapeToken(i + 1, x, y, { shape, color, sizeClass });
      }



      // —— NEW: Hover-highlighting for 2‑set Venn ——
      if (m0 < 0.34) {
        const geom2 = {
          U: { x: 200, y: 30, w: 900, h: 500 },
          A: { x: 525, y: 275, r: 180 },
          B: { x: 775, y: 275, r: 180 }
        };

        function drawBase2() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 4;
          ctx.strokeRect(geom2.U.x, geom2.U.y, geom2.U.w, geom2.U.h);
          ctx.beginPath(); ctx.arc(geom2.A.x, geom2.A.y, geom2.A.r, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath(); ctx.arc(geom2.B.x, geom2.B.y, geom2.B.r, 0, Math.PI * 2); ctx.stroke();
        }

        function drawURectPath() {
          ctx.beginPath();
          ctx.rect(geom2.U.x, geom2.U.y, geom2.U.w, geom2.U.h);
        }
        function drawCirclePath(c) {
          ctx.beginPath();
          ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
        }

        function getRegion2(x, y) {
          const inRect = (x >= geom2.U.x && x <= geom2.U.x + geom2.U.w && y >= geom2.U.y && y <= geom2.U.y + geom2.U.h);
          if (!inRect) return null;
          const inA = Math.hypot(x - geom2.A.x, y - geom2.A.y) <= geom2.A.r;
          const inB = Math.hypot(x - geom2.B.x, y - geom2.B.y) <= geom2.B.r;
          if (!inA && !inB) return 'Uminus';
          if (inA && !inB) return 'Aonly';
          if (!inA && inB) return 'Bonly';
          if (inA && inB) return 'AcapB';
          return null;
        }

        function highlightRegion2(region) {
          // Offscreen layer (create once per canvas if you prefer)
          const layer = document.createElement('canvas');
          layer.width = canvas.width;
          layer.height = canvas.height;
          const t = layer.getContext('2d');
        
          const HIGHLIGHT = 'rgba(0, 200, 0, 0.25)'; // visible tint
          const MASK = '#000';                       // opaque for masking
        
          // Local path helpers that draw into 't' (the offscreen ctx)
          const rectPath = () => { t.beginPath(); t.rect(geom2.U.x, geom2.U.y, geom2.U.w, geom2.U.h); };
          const circlePath = (c) => { t.beginPath(); t.arc(c.x, c.y, c.r, 0, Math.PI * 2); };
        
          // Build the region ONLY on the offscreen layer
          t.clearRect(0, 0, layer.width, layer.height);
          t.globalCompositeOperation = 'source-over';
          switch (region) {
            case 'Uminus':
              rectPath(); t.fillStyle = HIGHLIGHT; t.fill();
              t.globalCompositeOperation = 'destination-out';
              t.fillStyle = MASK; circlePath(geom2.A); t.fill();
              t.fillStyle = MASK; circlePath(geom2.B); t.fill();
              break;
        
            case 'Aonly':
              circlePath(geom2.A); t.fillStyle = HIGHLIGHT; t.fill();
              t.globalCompositeOperation = 'destination-out';
              t.fillStyle = MASK; circlePath(geom2.B); t.fill();
              break;
        
            case 'Bonly':
              circlePath(geom2.B); t.fillStyle = HIGHLIGHT; t.fill();
              t.globalCompositeOperation = 'destination-out';
              t.fillStyle = MASK; circlePath(geom2.A); t.fill();
              break;
        
            case 'AcapB':
              circlePath(geom2.A); t.fillStyle = HIGHLIGHT; t.fill();
              t.globalCompositeOperation = 'destination-in';
              t.fillStyle = MASK; circlePath(geom2.B); t.fill();
              break;
          }
        
          // Paint highlight over the base drawing (doesn't erase strokes)
          ctx.drawImage(layer, 0, 0);
        
          // Re-stroke outlines on top so they’re fully black (not green-tinted)
          ctx.save();
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 4;
          ctx.strokeRect(geom2.U.x, geom2.U.y, geom2.U.w, geom2.U.h);
          ctx.beginPath(); ctx.arc(geom2.A.x, geom2.A.y, geom2.A.r, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath(); ctx.arc(geom2.B.x, geom2.B.y, geom2.B.r, 0, Math.PI * 2); ctx.stroke();
          ctx.restore();
        }



        let draggingExponent = false;
        document.addEventListener('dragstart', (e) => {
          if (e.target && e.target.classList && e.target.classList.contains('draggable-exponent')) {
            draggingExponent = true;
          }
        });
        document.addEventListener('dragend', () => {
          draggingExponent = false;
          drawBase2();
        });

        canvas.addEventListener('dragover', (e) => {
          if (!draggingExponent) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          drawBase2();
          const region = getRegion2(x, y);
          if (region) highlightRegion2(region);
        });

        canvas.addEventListener('dragleave', () => {
          if (!draggingExponent) return;
          drawBase2();
        });
      }
else {
  // —— NEW: Hover-highlighting for 3‑set Venn ——
  const geom3 = {
    U: { x: 200, y: 30, w: 900, h: 500 },
    A: { x: 550, y: 200, r: 150 },
    B: { x: 750, y: 200, r: 150 },
    C: { x: 650, y: 350, r: 150 }
  };

  function drawBase3() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 4;
    ctx.strokeRect(geom3.U.x, geom3.U.y, geom3.U.w, geom3.U.h);
    ctx.beginPath(); ctx.arc(geom3.A.x, geom3.A.y, geom3.A.r, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.arc(geom3.B.x, geom3.B.y, geom3.B.r, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.arc(geom3.C.x, geom3.C.y, geom3.C.r, 0, Math.PI * 2); ctx.stroke();
  }

  function drawURectPath3() {
    ctx.beginPath();
    ctx.rect(geom3.U.x, geom3.U.y, geom3.U.w, geom3.U.h);
  }
  function drawCirclePath3(c) {
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
  }

  function getRegion3(x, y) {
    const inRect = (x >= geom3.U.x && x <= geom3.U.x + geom3.U.w && y >= geom3.U.y && y <= geom3.U.y + geom3.U.h);
    if (!inRect) return null;
    const inA = Math.hypot(x - geom3.A.x, y - geom3.A.y) <= geom3.A.r;
    const inB = Math.hypot(x - geom3.B.x, y - geom3.B.y) <= geom3.B.r;
    const inC = Math.hypot(x - geom3.C.x, y - geom3.C.y) <= geom3.C.r;

    if (!inA && !inB && !inC) return 'Uminus';
    if (inA && !inB && !inC) return 'Aonly';
    if (!inA && inB && !inC) return 'Bonly';
    if (!inA && !inB && inC) return 'Conly';
    if (inA && inB && !inC) return 'AcapBonly';
    if (inA && inC && !inB) return 'AcapConly';
    if (inB && inC && !inA) return 'BcapConly';
    if (inA && inB && inC) return 'AcapBcapC';
    return null;
  }

  function highlightRegion3(region) {
    const layer = document.createElement('canvas');
    layer.width = canvas.width;
    layer.height = canvas.height;
    const t = layer.getContext('2d');
  
    const HIGHLIGHT = 'rgba(0, 200, 0, 0.25)';
    const MASK = '#000';
  
    const rectPath = () => { t.beginPath(); t.rect(geom3.U.x, geom3.U.y, geom3.U.w, geom3.U.h); };
    const circlePath = (c) => { t.beginPath(); t.arc(c.x, c.y, c.r, 0, Math.PI * 2); };
  
    t.clearRect(0, 0, layer.width, layer.height);
    t.globalCompositeOperation = 'source-over';
  
    switch (region) {
      case 'Uminus':
        rectPath(); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.A); t.fill();
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        break;
  
      case 'Aonly':
        circlePath(geom3.A); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        break;
  
      case 'Bonly':
        circlePath(geom3.B); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.A); t.fill();
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        break;
  
      case 'Conly':
        circlePath(geom3.C); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.A); t.fill();
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        break;
  
      case 'AcapBonly':
        circlePath(geom3.A); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-in';
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        break;
  
      case 'AcapConly':
        circlePath(geom3.A); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-in';
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        break;
  
      case 'BcapConly':
        circlePath(geom3.B); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-in';
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        t.globalCompositeOperation = 'destination-out';
        t.fillStyle = MASK; circlePath(geom3.A); t.fill();
        break;
  
      case 'AcapBcapC':
        circlePath(geom3.A); t.fillStyle = HIGHLIGHT; t.fill();
        t.globalCompositeOperation = 'destination-in';
        t.fillStyle = MASK; circlePath(geom3.B); t.fill();
        t.globalCompositeOperation = 'destination-in';
        t.fillStyle = MASK; circlePath(geom3.C); t.fill();
        break;
    }
  
    ctx.drawImage(layer, 0, 0);
  
    // Re-stroke outlines on top
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 4;
    ctx.strokeRect(geom3.U.x, geom3.U.y, geom3.U.w, geom3.U.h);
    ctx.beginPath(); ctx.arc(geom3.A.x, geom3.A.y, geom3.A.r, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.arc(geom3.B.x, geom3.B.y, geom3.B.r, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.arc(geom3.C.x, geom3.C.y, geom3.C.r, 0, Math.PI * 2); ctx.stroke();
    ctx.restore();
  }



  let draggingExponent3 = false;
  document.addEventListener('dragstart', (e) => {
    if (e.target && e.target.classList && e.target.classList.contains('draggable-exponent')) {
      draggingExponent3 = true;
    }
  });
  document.addEventListener('dragend', () => {
    draggingExponent3 = false;
    drawBase3();
  });

  canvas.addEventListener('dragover', (e) => {
    if (!draggingExponent3) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    drawBase3();
    const region = getRegion3(x, y);
    if (region) highlightRegion3(region);
  });

  canvas.addEventListener('dragleave', () => {
    if (!draggingExponent3) return;
    drawBase3();
  });
}



      // —— Guard missing hintArea (keeps placeholder from erroring) ——
      if (typeof hintArea !== 'undefined' && hintArea) {
        hintIndex = 0;
        hintArea.innerHTML = "";
      }


    });


    const feedbackText = document.getElementById('feedbackText');
    


    
  </script>

  <audio id="click-sound" src="button.mp3" preload="auto"></audio>
  <audio id="set-sound" src="set2.mp3" preload="auto"></audio>
  
</body>
</html>
