

<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Personal website of Ben Fraser, with math education activities for students and teachers.">
  <meta charset="UTF-8" />
  <title>Equation of a Line Activity</title>
  <link rel="stylesheet" href="/style.css" />

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <style>
    .plot-wrap {
      display: flex;
      justify-content: center;
      margin: 0.75em 0 1.75em 0;
    }
    svg.plot {
      max-width: 100%;
      height: auto;
      border-radius: 14px;
      box-shadow: 0 6px 14px rgba(0,0,0,0.12);
      background: white;
    }
  </style>

</head>
<body>
  <header>
    <h1>Equation of a Line Activity</h1>
    <div id="nav-placeholder"></div>
      <script>
fetch("/nav.html")
  .then(response => response.text())
  .then(html => {
    document.getElementById("nav-placeholder").innerHTML = html;

    const currentPath = window.location.pathname.replace(/\/index\.html$/, "/");
    const navLinks = document.querySelectorAll("#nav-placeholder a");
    navLinks.forEach(link => {
      const linkPath = new URL(link.href).pathname.replace(/\/index\.html$/, "/");
      if (linkPath === currentPath) {
        link.classList.add("active");
      }
    });

    const s = document.createElement("script");
    s.src = "/mascot.js";
    s.defer = true;
    document.body.appendChild(s); 
  })
  .catch(err => {
    console.error("Failed to load nav:", err);
  });
</script>
  </header>
  <main>

    <p>A function \(f\) is a rule which assigns to each input \(a\) a unique output \(b\), written
      \[f(a) = b\]
      The input is called the independent variable, and the output the dependent variable.  They are called variables because they vary, and the 
      dependent variable is so named because its value <b>depends</b> on the value of the independent variable.  Traditionally, the letter \(x\) 
      is often used to represent the independent variable, and the letter \(y\) to represent the dependent variable.
    </p>
    
    <p>There are many ways of representing a function, but the most commonly used are an equation, and graphically.  For instance, the function 
      \[f(x) = 2x+3\]
      means that the input is doubled, and then 3 is added to it, to obtain its corresponding unique output.  One such pair of input-output is 
      called an <b>ordered pair</b>: ordered as
      \[(\text{independent variable}, \text{dependent variable})\]
      We could obtain several ordered pairs by "plugging in" various input numbers to the function.  For the above example, we could find 
      \[(-2,-1), (0,3), (3, 9)\]
      etc...  A <b>table of values</b> is one way we could organize a large set of inputs and their corresponding outputs:
      \[
\begin{array}{|c|c|}
\hline
x & f(x) \\
\hline
-4 & -5 \\
-3 & -3 \\
-2 & -1 \\
-1 & 1 \\
0 & 3 \\
1 & 5 \\
2 & 7 \\
3 & 9 \\
4 & 11 \\
\hline
\end{array}
\]
      There was an oversight in the preceding definition of our function.  We did not specify its <b>domain</b>: the set of permitted inputs.  Our 
      table of values above restricted our attention to integer inputs, but if we had written
      \[f: \mathbb{R} \mapsto \mathbb{R}\]
      this would tell us that the function's domain is the set of real numbers, and so is its codomain (the set of allowable outputs).  The set of 
      outputs the function actually achieves is called its <b>range</b>.  The above could also be read as "\(f\) is a map from the real numbers to 
      the real numbers".
    </p>

      
    <p>Our perhaps most familiar means of representing a function is graphically.  We plot the set of ordered pairs on a plane, where its horizontal 
      position is determined by the independent variable (on the \(x\)-axis) and its vertical position is determined by the dependent variable (on the 
      \(y\)-axis).  In the preceding example, if our domain and codomain were the set of integers,
      \[f(x) = 2x + 3, \hspace{2cm} f:\mathbb{Z} \mapsto \mathbb{Z}\]
      then we would obtain a scatter plot:
    </p>

    <div class="plot-wrap">
      <svg id="integer-plot" class="plot" width="360" height="360" viewBox="0 0 360 360" aria-label="Integer-domain plot of f(x)=2x+3"></svg>
    </div>

    <p>Whereas if the domain and codomain were the set of real numbers, we'd obtain a line:</p>
    <div class="plot-wrap">
      <svg id="real-plot" class="plot" width="360" height="360" viewBox="0 0 360 360" aria-label="Real-domain plot of f(x)=2x+3"></svg>
    </div>

    <p>Often we don't start with the equation of a line, but have one or more points on it.  If we have either two points on the line, or one point 
      and its <b>slope</b>, then we have enough information to find its equation, and graph it.  Slope is a measure of whether and to what degree a 
      function is increasing or decreasing.  For instance, in the example above, the function has a slope of 2: for every increase in the independent 
      variable by 1, the dependent variable increases by 2.
    </p>

    <p>If we have two points, we can determine the slope of the line which passes through both of them.  For instance, given the points
      \[(9,-5), (-6,0)\]
      we determine the slope using the \(\frac{\text{rise}}{\text{run}}\) formula, which gives a ratio between the change in \(y\) to the change in 
      \(x\) (denoted using the Greek letter \(\Delta\), \(\frac{\Delta x}{\Delta y}\).  We traditionally use the letter \(m\) to denote slope:
      \[m = \frac{\Delta y}{\Delta x} = \frac{y_2 - y_1}{x_2 - x_1} = \frac{0 - (-5)}{-6 - 9} = \frac{5}{-15} = -\frac{1}{3}\]
      (where we assigned to each of the ordered pairs above the role of first/second point, so \((-6,0) = (x_2,y_2)\) and \((9,-5) = (x_1,y_1)\)).
    </p>

    <p>We then plug our known information into the point-slope form of the equation of a line:
      \[y - y_1 = m(x - x_1) \implies y - (-5) = -\frac{1}{3}(x - 9)\]
      It is often easier to graph a line if we put its equation in a familar form, the slope-intercept form:
      \[y = mx +b\]
      where \(b\) is the <b>\(y\)-intercept</b> of the line, where it intersects the \(y\)-axis (and hence the \(x\)-coordinate of that point is zero). 
      Manipulating our previous equation:
      \[y - (-5) = -\frac{1}{3}(x - 9) \implies y + 5 = -\frac{1}{3}x + 3 \implies y = -\frac{1}{3}x - 2\]
      we get it into that form.  We then know the point \((0,-2\) is on the line, and can plot the other points by using the slope (for every 1 we go 
      to the right, we go \(\frac{1}{3}\) down, so for every 3 we go to the right, we go one down, and similarly, for every 3 we go to the left, we 
      go 1 up):
    </p>


    

    <div class="button-container">
      <button id="start-btn" class="rubber-button">Start!</button>
    </div>
    
    <p id="question-text" class="math"></p>

    <div class="button-container">
      <button id="hint-btn" class="rubber-button">Hint</button>
    </div>
    
    <div id="hint-area" class="math" style="margin-top: 1em; text-align: center"></div>


    <div id="answer-section" style="margin-top: 20px; text-align: center;">
      <label for="user-answer">Enter your answer:</label>
      <input type="text" id="user-answer" />
      <button id="check-answer-btn" class="rubber-button" style="margin-left: 0.5em;">Check Answer</button>
      <p id="answer-feedback" style="font-weight: bold; margin-top: 10px;"></p>
    </div>

  </main>
  <script>
  const hintBtn = document.getElementById('hint-btn');
  const hintArea = document.getElementById('hint-area');
  let hintSteps = [];
  let hintIndex = 0;

  const startBtn = document.getElementById('start-btn');
  const questionText = document.getElementById('question-text');

  const answerInput = document.getElementById('user-answer');
  const feedback = document.getElementById('answer-feedback');

  // Correct answer stored as reduced fraction num/den
  let currentAnsNum = null;
  let currentAnsDen = null;

  // -----------------------------
  // Helpers
  // -----------------------------
  function playSound(id) {
    const s = document.getElementById(id);
    if (s) {
      s.currentTime = 0;
      s.play();
    }
  }

  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }

  function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b !== 0) {
      const t = a % b;
      a = b;
      b = t;
    }
    return a === 0 ? 1 : a;
  }

  function reduceFrac(num, den) {
    if (den < 0) { den = -den; num = -num; }
    const g = gcd(num, den);
    return [num / g, den / g];
  }

  function setAnswer(num, den) {
    const r = reduceFrac(num, den);
    currentAnsNum = r[0];
    currentAnsDen = r[1];
  }

  function resetUIForNewQuestion() {
    feedback.textContent = '';
    feedback.style.color = 'black';
    answerInput.value = '';
    hintArea.innerHTML = '';
    hintSteps = [];
    hintIndex = 0;
  }


  function typeset(elements = []) {
    if (!window.MathJax) return;
    if (MathJax.typesetPromise) {
      if (elements.length > 0) MathJax.typesetPromise(elements);
      else MathJax.typesetPromise();
      return;
    }
    if (MathJax.typeset) {
      if (elements.length > 0) MathJax.typeset(elements);
      else MathJax.typeset();
    }
  }

  function toDecimalString(num, den) {
    const x = num / den;
    let s = x.toFixed(2);
    s = s.replace(/0+$/, '').replace(/\.$/, '');
    return s;
  }

  function joinWithOr(items) {
    if (items.length === 1) return items[0];
    if (items.length === 2) return `${items[0]} or ${items[1]}`;
    return `${items.slice(0, -1).join(', ')}, or ${items[items.length - 1]}`;
  }

  function singularize(word) {
    // Good enough for your current banks (apples->apple, SUVs->SUV, etc.)
    if (word.endsWith('s')) return word.slice(0, -1);
    return word;
  }

  function articleFor(word) {
    const first = word[0];
    const vowelLetter = /^[aeiou]/i.test(first);
    const anInitialism = /^[FHLMNRSX]/.test(first); // “an” F, H, L, M, N, R, S, X
    return (vowelLetter || anInitialism) ? 'an' : 'a';
  }



  // -----------------------------
  // Plotting (SVG): reusable for this activity
  // -----------------------------
  function plotLinearFunction(svgOrId, f, opts = {}) {
    const svg = (typeof svgOrId === 'string') ? document.getElementById(svgOrId) : svgOrId;
    if (!svg) return;

    const domain = opts.domain || 'reals'; // 'reals' or 'integers'
    const xMin = -10, xMax = 10, yMin = -10, yMax = 10;
    const tickStep = 2;

    // Clear old contents
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    // Ensure viewBox exists (for responsive scaling)
    const w = svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width ? svg.viewBox.baseVal.width : (svg.width && svg.width.baseVal ? svg.width.baseVal.value : 360);
    const h = svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.height ? svg.viewBox.baseVal.height : (svg.height && svg.height.baseVal ? svg.height.baseVal.value : 360);
    if (!svg.getAttribute('viewBox')) svg.setAttribute('viewBox', `0 0 ${w} ${h}`);

    const pad = 34;

    const NS = "http://www.w3.org/2000/svg";
    const el = (name) => document.createElementNS(NS, name);

    const X = (x) => pad + (x - xMin) / (xMax - xMin) * (w - 2 * pad);
    const Y = (y) => h - pad - (y - yMin) / (yMax - yMin) * (h - 2 * pad);

    // A gentle "card" border inside the SVG for your rounded-corner vibe
    const frame = el('rect');
    frame.setAttribute('x', pad);
    frame.setAttribute('y', pad);
    frame.setAttribute('width', w - 2 * pad);
    frame.setAttribute('height', h - 2 * pad);
    frame.setAttribute('rx', 12);
    frame.setAttribute('ry', 12);
    frame.setAttribute('fill', 'white');
    frame.setAttribute('stroke', 'rgba(0,0,0,0.25)');
    frame.setAttribute('stroke-width', '1');
    svg.appendChild(frame);

    // Grid
    const grid = el('g');
    grid.setAttribute('stroke', 'rgba(0,0,0,0.08)');
    grid.setAttribute('stroke-width', '1');

    for (let t = xMin; t <= xMax; t += tickStep) {
      const v = el('line');
      v.setAttribute('x1', X(t));
      v.setAttribute('y1', Y(yMin));
      v.setAttribute('x2', X(t));
      v.setAttribute('y2', Y(yMax));
      grid.appendChild(v);
    }
    for (let t = yMin; t <= yMax; t += tickStep) {
      const hline = el('line');
      hline.setAttribute('x1', X(xMin));
      hline.setAttribute('y1', Y(t));
      hline.setAttribute('x2', X(xMax));
      hline.setAttribute('y2', Y(t));
      grid.appendChild(hline);
    }
    svg.appendChild(grid);

    // Axes
    const axes = el('g');
    axes.setAttribute('stroke', 'rgba(0,0,0,0.85)');
    axes.setAttribute('stroke-width', '1.5');

    // x-axis (y=0)
    const xAxis = el('line');
    xAxis.setAttribute('x1', X(xMin));
    xAxis.setAttribute('y1', Y(0));
    xAxis.setAttribute('x2', X(xMax));
    xAxis.setAttribute('y2', Y(0));
    axes.appendChild(xAxis);

    // y-axis (x=0)
    const yAxis = el('line');
    yAxis.setAttribute('x1', X(0));
    yAxis.setAttribute('y1', Y(yMin));
    yAxis.setAttribute('x2', X(0));
    yAxis.setAttribute('y2', Y(yMax));
    axes.appendChild(yAxis);

    svg.appendChild(axes);

    // Ticks + labels
    const ticks = el('g');
    const tickLen = 6;

    const labelStyle = (txt) => {
      txt.setAttribute('font-size', '12');
      txt.setAttribute('fill', 'rgba(0,0,0,0.75)');
      txt.setAttribute('font-family', 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif');
    };

    for (let t = xMin; t <= xMax; t += tickStep) {
      const mark = el('line');
      mark.setAttribute('x1', X(t));
      mark.setAttribute('y1', Y(0) - tickLen / 2);
      mark.setAttribute('x2', X(t));
      mark.setAttribute('y2', Y(0) + tickLen / 2);
      mark.setAttribute('stroke', 'rgba(0,0,0,0.7)');
      mark.setAttribute('stroke-width', '1');
      ticks.appendChild(mark);

      const lab = el('text');
      labelStyle(lab);
      lab.setAttribute('x', X(t));
      lab.setAttribute('y', Y(0) + 18);
      lab.setAttribute('text-anchor', 'middle');
      lab.textContent = t.toString();
      ticks.appendChild(lab);
    }

    for (let t = yMin; t <= yMax; t += tickStep) {
      const mark = el('line');
      mark.setAttribute('x1', X(0) - tickLen / 2);
      mark.setAttribute('y1', Y(t));
      mark.setAttribute('x2', X(0) + tickLen / 2);
      mark.setAttribute('y2', Y(t));
      mark.setAttribute('stroke', 'rgba(0,0,0,0.7)');
      mark.setAttribute('stroke-width', '1');
      ticks.appendChild(mark);

      if (t !== 0) { // avoid clutter at the origin
        const lab = el('text');
        labelStyle(lab);
        lab.setAttribute('x', X(0) - 10);
        lab.setAttribute('y', Y(t) + 4);
        lab.setAttribute('text-anchor', 'end');
        lab.textContent = t.toString();
        ticks.appendChild(lab);
      }
    }

    svg.appendChild(ticks);

    // Axis labels at the ends
    const axisLabels = el('g');

    const xLab = el('text');
    labelStyle(xLab);
    xLab.setAttribute('font-size', '14');
    xLab.setAttribute('font-weight', '700');
    xLab.setAttribute('x', X(xMax) + 12);
    xLab.setAttribute('y', Y(0) + 5);
    xLab.setAttribute('text-anchor', 'start');
    xLab.textContent = 'x';
    axisLabels.appendChild(xLab);

    const yLab = el('text');
    labelStyle(yLab);
    yLab.setAttribute('font-size', '14');
    yLab.setAttribute('font-weight', '700');
    yLab.setAttribute('x', X(0) + 6);
    yLab.setAttribute('y', Y(yMax) - 10);
    yLab.setAttribute('text-anchor', 'start');
    yLab.textContent = 'y';
    axisLabels.appendChild(yLab);

    svg.appendChild(axisLabels);

    // Clip region so the plotted line/points stay inside the frame
    const defs = el('defs');
    const clipPath = el('clipPath');
    const clipId = `clip-${svg.id || Math.random().toString(16).slice(2)}`;
    clipPath.setAttribute('id', clipId);

    const clipRect = el('rect');
    clipRect.setAttribute('x', pad);
    clipRect.setAttribute('y', pad);
    clipRect.setAttribute('width', w - 2 * pad);
    clipRect.setAttribute('height', h - 2 * pad);
    clipRect.setAttribute('rx', 12);
    clipRect.setAttribute('ry', 12);

    clipPath.appendChild(clipRect);
    defs.appendChild(clipPath);
    svg.appendChild(defs);

    const plotLayer = el('g');
    plotLayer.setAttribute('clip-path', `url(#${clipId})`);
    svg.appendChild(plotLayer);

    // --- Plot ---
    if (domain === 'integers') {
      const pts = el('g');
      for (let x = xMin; x <= xMax; x++) {
        const y = f(x);
        if (typeof y !== 'number' || !Number.isFinite(y)) continue;
        if (y < yMin || y > yMax) continue;

        const dot = el('circle');
        dot.setAttribute('cx', X(x));
        dot.setAttribute('cy', Y(y));
        dot.setAttribute('r', '4.3');
        dot.setAttribute('fill', 'rgba(220, 53, 69, 0.95)'); // friendly red
        dot.setAttribute('stroke', 'rgba(0,0,0,0.25)');
        dot.setAttribute('stroke-width', '1');
        pts.appendChild(dot);
      }
      plotLayer.appendChild(pts);
    } else {
      // Reals: draw the segment clipped to the viewing box in world coords
      function clipLineToRect(x1, y1, x2, y2, rxMin, rxMax, ryMin, ryMax) {
        // Liang–Barsky
        let t0 = 0, t1 = 1;
        const dx = x2 - x1, dy = y2 - y1;
        const p = [-dx, dx, -dy, dy];
        const q = [x1 - rxMin, rxMax - x1, y1 - ryMin, ryMax - y1];

        for (let i = 0; i < 4; i++) {
          if (p[i] === 0) {
            if (q[i] < 0) return null;
          } else {
            const r = q[i] / p[i];
            if (p[i] < 0) {
              if (r > t1) return null;
              if (r > t0) t0 = r;
            } else {
              if (r < t0) return null;
              if (r < t1) t1 = r;
            }
          }
        }
        return {
          x1: x1 + t0 * dx,
          y1: y1 + t0 * dy,
          x2: x1 + t1 * dx,
          y2: y1 + t1 * dy
        };
      }

      const A = { x: xMin, y: f(xMin) };
      const B = { x: xMax, y: f(xMax) };
      const clipped = clipLineToRect(A.x, A.y, B.x, B.y, xMin, xMax, yMin, yMax);

      if (clipped) {
        const seg = el('line');
        seg.setAttribute('x1', X(clipped.x1));
        seg.setAttribute('y1', Y(clipped.y1));
        seg.setAttribute('x2', X(clipped.x2));
        seg.setAttribute('y2', Y(clipped.y2));
        seg.setAttribute('stroke', 'rgba(13, 110, 253, 0.95)'); // friendly blue
        seg.setAttribute('stroke-width', '3.2');
        seg.setAttribute('stroke-linecap', 'round');
        plotLayer.appendChild(seg);
      }
    }
  }


  function fracTex(num, den) {
    const r = reduceFrac(num, den);
    const n = r[0], d = r[1];
    if (d === 1) return `\\frac{${n}}{${d}}`;
    return `\\frac{${n}}{${d}}`;
  }

  function parseUserAnswer(raw) {
    // Accept:
    //  - integer: "3"
    //  - fraction: "3/8"
    //  - decimal: "0.375"
    //
    // Returns:
    //  { kind:'exact', num, den } for integer/fraction
    //  { kind:'decimal', value, relTol } for decimals (graded by relative tolerance)
    const s = raw.replace(/\s+/g, '');

    // Fraction a/b
    const fracMatch = s.match(/^([+-]?\d+)\/([+-]?\d+)$/);
    if (fracMatch) {
      const a = parseInt(fracMatch[1], 10);
      const b = parseInt(fracMatch[2], 10);
      if (b === 0) return { error: 'Denominator cannot be 0.' };
      const [rn, rd] = reduceFrac(a, b);
      return { kind: 'exact', num: rn, den: rd };
    }

    // Integer
    const intMatch = s.match(/^[+-]?\d+$/);
    if (intMatch) {
      const a = parseInt(s, 10);
      return { kind: 'exact', num: a, den: 1 };
    }

    // Decimal
    const decMatch = s.match(/^[+-]?\d*\.\d+$/);
    if (decMatch) {
      const value = Number(s);
      if (!Number.isFinite(value)) return { error: 'That decimal does not look valid.' };
      if (value < 0) return { error: 'Probabilities cannot be negative.' };
      // Allow decimals; grade with 0.01% relative tolerance
      return { kind: 'decimal', value, relTol: 0.0001 };
    }

    return { error: 'I couldn’t parse that. Use a fraction like 3/8 or a decimal like 0.375.' };
  }

  function isCorrect(parsed) {
    if (currentAnsNum === null || currentAnsDen === null) return false;
    const correctVal = currentAnsNum / currentAnsDen;

    if (!parsed || parsed.error) return false;

    if (parsed.kind === 'exact') {
      const [uNum, uDen] = reduceFrac(parsed.num, parsed.den);
      return (uNum === currentAnsNum && uDen === currentAnsDen);
    }

    if (parsed.kind === 'decimal') {
      const denom = Math.max(1e-12, Math.abs(correctVal));
      return Math.abs(parsed.value - correctVal) <= parsed.relTol * denom;
    }

    return false;
  }

  // -----------------------------
  // Banks
  // -----------------------------
  const type1Bank = [
    { categorySing: 'fruit', categoryPlur: 'fruits', items: ['apples', 'bananas', 'oranges', 'pears', 'grapefruits'] },
    { categorySing: 'animal', categoryPlur: 'animals', items: ['cats', 'dogs', 'birds', 'bears', 'lions'] },
    { categorySing: 'musical instrument', categoryPlur: 'musical instruments', items: ['trumpets', 'flutes', 'clarinets', 'tubas', 'saxophones'] },
    { categorySing: 'piece of furniture', categoryPlur: 'pieces of furniture', items: ['chairs', 'tables', 'couches', 'beds', 'dressers'] },
    { categorySing: 'utensil', categoryPlur: 'utensils', items: ['forks', 'spoons', 'knives', 'spatulas', 'whisks'] },
    { categorySing: 'vehicle', categoryPlur: 'vehicles', items: ['sedans', 'jeeps', 'SUVs', 'trucks', 'vans'] },
    { categorySing: 'shape', categoryPlur: 'shapes', items: ['squares', 'triangles', 'circles', 'pentagons', 'hexagons'] }
  ];

  const type3Bank = [
    { e: 'it rains', f: 'the temperature is below 5°C' },
    { e: 'you score a touchdown', f: 'you are the game MVP' },
    { e: 'the Best Actor winner is from Europe', f: 'the Best Actor winner is over 40 years old' },
    { e: 'a newborn has brown hair', f: 'a newborn weighs more than 8 lbs at birth' },
    { e: 'a randomly selected email is spam', f: 'the email contains the word “free”' },
    { e: 'a randomly selected day is a weekend', f: 'it rains that day' },
    { e: 'a student passes the final exam', f: 'the student studied at least 5 hours' },
    { e: 'a customer buys something', f: 'the customer used a coupon' }
  ];

  const type4Bank = [
    {
      population: 'employees at Ben Co',
      member: 'employee',
      aLabel: 'lawyers at Ben Co',
      bLabel: 'employees at Ben Co earning more than 100K'
    },
    {
      population: 'students at VIU',
      member: 'student',
      aLabel: 'students enrolled in Math 132',
      bLabel: 'students enrolled in Math 161'
    },
    {
      population: 'players in the NHL',
      member: 'player',
      aLabel: 'centers in the NHL',
      bLabel: 'players in the NHL who have averaged more than a point per game'
    },
    {
      population: 'books in a library',
      member: 'book',
      aLabel: 'fiction books',
      bLabel: 'books currently checked out'
    },
    {
      population: 'cars in a parking lot',
      member: 'car',
      aLabel: 'cars that are SUVs',
      bLabel: 'cars that are electric'
    }
  ];

  // -----------------------------
  // Type 1
  // -----------------------------
  function generateType1() {
    const scenario = type1Bank[randInt(0, type1Bank.length - 1)];

    const N = randInt(20, 80);
    const k = randInt(2, 5);

    // choose k distinct items from the 5
    const indices = [0, 1, 2, 3, 4];
    for (let i = indices.length - 1; i > 0; i--) {
      const j = randInt(0, i);
      [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    const chosenTypesIdx = indices.slice(0, k);
    const chosenTypes = chosenTypesIdx.map(i => scenario.items[i]);

    // random positive parts summing to N
    let cuts = [];
    for (let i = 0; i < k - 1; i++) cuts.push(randInt(1, N - 1));
    cuts.sort((a, b) => a - b);

    const counts = [];
    let prev = 0;
    for (let i = 0; i < cuts.length; i++) {
      counts.push(cuts[i] - prev);
      prev = cuts[i];
    }
    counts.push(N - prev);

    // choose between 1 and k-1 of the pieces for the OR question
    const m = randInt(1, k - 1);
    const idx2 = [...Array(k).keys()];
    for (let i = idx2.length - 1; i > 0; i--) {
      const j = randInt(0, i);
      [idx2[i], idx2[j]] = [idx2[j], idx2[i]];
    }
    const picked = idx2.slice(0, m).sort((a, b) => a - b);

    const favorable = picked.reduce((acc, i) => acc + counts[i], 0);
    setAnswer(favorable, N);

    const breakdown = chosenTypes
      .map((t, i) => `${counts[i]} ${t}`)
      .join(', ');

    const askedTypes = picked.map(i => chosenTypes[i]);
    const askedSingles = askedTypes.map(t => {
      const s = singularize(t);
      return `${articleFor(s)} ${s}`;
    });
    const askedPhrase = joinWithOr(askedSingles);

    questionText.textContent =
      `A ${scenario.categorySing} is randomly selected from a set of ${N} ${scenario.categoryPlur}. ` +
      `There are ${breakdown}. ` +
      `What is the probability that ${askedPhrase} is selected?`;

    hintSteps = [
  `Add the counts for the types listed in the question to get the number of favorable outcomes.`,
  `There are ${picked.map(i => counts[i]).join(' + ')} = ${favorable} ${scenario.categoryPlur} which are ${askedTypes.join(' or ')}.`,
  `Divide by the total number of outcomes (the total size of the set).`,
  `The proportion of ${scenario.categoryPlur} which are ${askedTypes.join(' or ')} is \\(${fracTex(favorable, N)}\\).`
];
  }

  // -----------------------------
  // Type 2
  // -----------------------------
  function generateType2() {
    const n = randInt(10, 100);
    const r = randInt(1, 3);

    const points = new Set();
    while (points.size < 2 * r) points.add(randInt(1, n));
    const sorted = Array.from(points).sort((a, b) => a - b);

    const intervals = [];
    for (let i = 0; i < sorted.length; i += 2) {
      let a = sorted[i], b = sorted[i + 1];
      if (b < a) [a, b] = [b, a];
      intervals.push([a, b]);
    }
    intervals.sort((I, J) => I[0] - J[0]);

    const disjoint = [];
    for (const [s, t] of intervals) {
      if (disjoint.length === 0) disjoint.push([s, t]);
      else {
        const last = disjoint[disjoint.length - 1];
        if (s > last[1]) disjoint.push([s, t]);
        else {
          const ns = last[1] + 1;
          if (ns <= t) disjoint.push([ns, t]);
        }
      }
    }

    while (disjoint.length < r) {
      const x = randInt(1, n);
      let ok = true;
      for (const [s, t] of disjoint) if (x >= s && x <= t) ok = false;
      if (ok) disjoint.push([x, x]);
      if (disjoint.length > 10) break;
    }

    disjoint.sort((I, J) => I[0] - J[0]);
    const finalIntervals = disjoint.slice(0, r);

    let outerUsed = 0;
    const phrases = finalIntervals.map(([s, t]) => {
      if (s === 1 && outerUsed < 2) {
        outerUsed++;
        return `less than ${t + 1}`;
      }
      if (t === n && outerUsed < 2) {
        outerUsed++;
        return `${s} or higher`;
      }
      if (s === t) return `exactly ${s}`;
      return `between ${s} and ${t} (inclusive)`;
    });

    const favorable = finalIntervals.reduce((acc, [s, t]) => acc + (t - s + 1), 0);
    setAnswer(favorable, n);

    questionText.textContent =
      `A ${n}-sided die is rolled. ` +
      `What is the probability that the number rolled is ${joinWithOr(phrases)}?`;

    hintSteps = [
  `Count how many outcomes satisfy at least one of the listed conditions.`,
  `There are ${favorable} natural numbers which are ${joinWithOr(phrases)}.`,
  `Divide by the total number of outcomes (${n}).`,
  `The proportion of natural numbers which are ${n} or less that are ${joinWithOr(phrases)} is \\(${fracTex(favorable, n)}\\).`
];
  }

  // -----------------------------
  // Type 3
  // -----------------------------
  function generateType3() {
    const scenario = type3Bank[randInt(0, type3Bank.length - 1)];

    const den = 100;
    const pE = randInt(10, 80);
    const pF = randInt(10, 80);

    const minInt = Math.max(0, pE + pF - den);
    const maxInt = Math.min(pE, pF);
    const pInt = randInt(minInt, maxInt);

    const pUnion = pE + pF - pInt;
    const giveUnion = Math.random() < 0.5;

    if (giveUnion) {
      setAnswer(pInt, den);
      questionText.textContent =
        `There is a ${toDecimalString(pE, den)} probability that ${scenario.e}, ` +
        `a ${toDecimalString(pF, den)} probability that ${scenario.f}, ` +
        `and a ${toDecimalString(pUnion, den)} probability that ${scenario.e} or ${scenario.f}. ` +
        `What is the probability that ${scenario.e} and ${scenario.f}?`;
    } else {
      setAnswer(pUnion, den);
      questionText.textContent =
        `There is a ${toDecimalString(pE, den)} probability that ${scenario.e}, ` +
        `a ${toDecimalString(pF, den)} probability that ${scenario.f}, ` +
        `and a ${toDecimalString(pInt, den)} probability that ${scenario.e} and ${scenario.f}. ` +
        `What is the probability that ${scenario.e} or ${scenario.f}?`;
    }

    hintSteps = (() => {
  const eText = scenario.e;
  const fText = scenario.f;

  if (giveUnion) {
    return [
      `Use inclusion-exclusion.`,
      `Rearrange depending on which quantity you’re missing.`,
      `\\(P(E \\cap F) = P(E) + P(F) - P(E \\cup F)\\)`,
      `Let \\(E\\) be the event that ${eText}, and let \\(F\\) be the event that ${fText}.`,
      `Substitute: \\(P(E \\cap F) = ${fracTex(pE, den)} + ${fracTex(pF, den)} - ${fracTex(pUnion, den)} = ${fracTex(pInt, den)}\\).`
    ];
  } else {
    return [
      `Use inclusion-exclusion.`,
      `Rearrange depending on which quantity you’re missing.`,
      `\\(P(E \\cup F) = P(E) + P(F) - P(E \\cap F)\\)`,
      `Let \\(E\\) be the event that ${eText}, and let \\(F\\) be the event that ${fText}.`,
      `Substitute: \\(P(E \\cup F) = ${fracTex(pE, den)} + ${fracTex(pF, den)} - ${fracTex(pInt, den)} = ${fracTex(pUnion, den)}\\).`
    ];
  }
})();
  }

  // -----------------------------
  // Type 4
  // -----------------------------
  function generateType4() {
    const scenario = type4Bank[randInt(0, type4Bank.length - 1)];

    const N = randInt(80, 600);
    const a = randInt(10, Math.floor(0.75 * N));
    const b = randInt(10, Math.floor(0.75 * N));

    const giveUnion = Math.random() < 0.5;

    let u;
    let inter;

    if (giveUnion) {
      const uMin = Math.max(a, b);
      const uMax = Math.min(N, a + b);
      u = randInt(uMin, uMax);
      inter = a + b - u;

      setAnswer(inter, N);

      questionText.textContent =
        `There are ${N} ${scenario.population}. ` +
        `${a} are ${scenario.aLabel}, ${b} are ${scenario.bLabel}, ` +
        `and ${u} are ${scenario.aLabel} or ${scenario.bLabel}. ` +
        `If a ${scenario.member} is selected at random, what is the probability they are ` +
        `${scenario.aLabel} and ${scenario.bLabel}?`;
    } else {
      const iMin = Math.max(0, a + b - N);
      const iMax = Math.min(a, b);
      inter = randInt(iMin, iMax);
      u = a + b - inter;

      setAnswer(u, N);

      questionText.textContent =
        `There are ${N} ${scenario.population}. ` +
        `${a} are ${scenario.aLabel}, ${b} are ${scenario.bLabel}, ` +
        `and ${inter} are ${scenario.aLabel} and ${scenario.bLabel}. ` +
        `If a ${scenario.member} is selected at random, what is the probability they are ` +
        `${scenario.aLabel} or ${scenario.bLabel}?`;
    }

    hintSteps = (() => {
  const A = scenario.aLabel;
  const B = scenario.bLabel;

  if (giveUnion) {
    return [
      `Use inclusion-exclusion: \\(|A \\cup B| = |A| + |B| - |A \\cap B|\\).`,
      `Find the missing amount, \\(|A \\cap B|\\).`,
      `Let \\(A =\\) ${A} and let \\(B =\\) ${B}.`,
      `Substitute: \\(${u} = ${a} + ${b} - |A \\cap B|\\).`,
      `So \\(|A \\cap B| = ${a} + ${b} - ${u} = ${inter}\\).`,
      `Divide by the total population to get the probability.`,
      `The proportion of ${scenario.population} which are ${A} and ${B} is \\(${fracTex(inter, N)}\\).`
    ];
  } else {
    return [
      `Use inclusion-exclusion: \\(|A \\cup B| = |A| + |B| - |A \\cap B|\\).`,
      `Find the missing amount, \\(|A \\cup B|\\).`,
      `Let \\(A =\\) ${A} and let \\(B =\\) ${B}.`,
      `Substitute: \\(|A \\cup B| = ${a} + ${b} - ${inter}\\).`,
      `So \\(|A \\cup B| = ${u}\\).`,
      `Divide by the total population to get the probability.`,
      `The proportion of ${scenario.population} which are ${A} or ${B} is \\(${fracTex(u, N)}\\).`
    ];
  }
})();
  }

  // -----------------------------
  // Start: generate a question
  // -----------------------------
  startBtn.addEventListener('click', () => {
    playSound('click-sound');
    resetUIForNewQuestion();

    const qType = randInt(1, 4);

    if (qType === 1) generateType1();
    if (qType === 2) generateType2();
    if (qType === 3) generateType3();
    if (qType === 4) generateType4();
  });

  // -----------------------------
  // Check answer
  // -----------------------------
  document.getElementById('check-answer-btn').addEventListener('click', () => {
    playSound('click-sound');

    const raw = answerInput.value.trim();
    if (!raw) {
      feedback.textContent = 'Please enter an answer.';
      feedback.style.color = 'black';
      return;
    }

    const parsed = parseUserAnswer(raw);
    if (parsed.error) {
      feedback.textContent = parsed.error;
      feedback.style.color = 'black';
      return;
    }

    if (isCorrect(parsed)) {
      feedback.textContent = 'Correct!';
      feedback.style.color = 'green';
    } else {
      const exact = `${currentAnsNum}/${currentAnsDen}`;
      const dec = (currentAnsNum / currentAnsDen).toFixed(6).replace(/0+$/, '').replace(/\.$/, '');
      feedback.textContent = `Not quite. Correct answer is ${exact} (≈ ${dec}).`;
      feedback.style.color = 'crimson';
    }
  });

  // -----------------------------
  // Hint button (centered)
  // -----------------------------
  hintBtn.addEventListener('click', () => {
    playSound('click-sound');

    if (!hintSteps || hintSteps.length === 0) {
      const hintPara = document.createElement('div');
      hintPara.classList.add('hint-step');
      hintPara.style.textAlign = 'center';
      hintPara.textContent = 'No hints are available for this question.';
      hintArea.appendChild(hintPara);
      typeset([hintPara]);
      return;
    }

    if (hintIndex < hintSteps.length) {
      const hintPara = document.createElement('div');
      hintPara.classList.add('hint-step');
      hintPara.style.textAlign = 'center';
      hintPara.innerHTML = hintSteps[hintIndex];
      hintArea.appendChild(hintPara);
      typeset([hintPara]);
      hintIndex++;
    }
  });

  // -----------------------------
  // Demo plots for the intro text
  // -----------------------------
  plotLinearFunction('integer-plot', (x) => 2 * x + 3, { domain: 'integers' });
  plotLinearFunction('real-plot', (x) => 2 * x + 3, { domain: 'reals' });

</script>

  <audio id="click-sound" src="button.mp3" preload="auto"></audio>
  <audio id="set-sound" src="set2.mp3" preload="auto"></audio>

</body>
</html>
