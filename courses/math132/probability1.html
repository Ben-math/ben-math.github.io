<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Personal website of Ben Fraser, with math education activities for students and teachers.">
  <meta charset="UTF-8" />
  <title>Probability I Activity</title>
  <link rel="stylesheet" href="/style.css" />

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>Probability I Activity</h1>
    <div id="nav-placeholder"></div>
      <script>
fetch("/nav.html")
  .then(response => response.text())
  .then(html => {
    document.getElementById("nav-placeholder").innerHTML = html;

    const currentPath = window.location.pathname.replace(/\/index\.html$/, "/");
    const navLinks = document.querySelectorAll("#nav-placeholder a");
    navLinks.forEach(link => {
      const linkPath = new URL(link.href).pathname.replace(/\/index\.html$/, "/");
      if (linkPath === currentPath) {
        link.classList.add("active");
      }
    });

    const s = document.createElement("script");
    s.src = "/mascot.js";
    s.defer = true;
    document.body.appendChild(s); 
  })
  .catch(err => {
    console.error("Failed to load nav:", err);
  });
</script>
  </header>
  <main>

    <p>We begin our introduction to probability with the simplest case: when an experiment is performed with equally likely outcomes.  Here
    "experiment" need not refer to the hard science you had in mind, but something as simple as rolling a 6-sided die.  There are 6 equally likely
    outcomes: the numbers from one to six.  We call the set of all possible outcomes the <b>sample space</b>, denoted by S:
    \[S = \{1,2,3,4,5,6\}\]
      An <b>outcome</b> is a single element of the sample space, and an <b>event</b> is a subset of the sample space. Each of the six outcomes in this 
      example are equally likely (assuming the die is not weighted), and it is not possible for any two of the outcomes to occur.  This property: 
      that the outcomes do not overlap, is that they are <b>mutually exclusive</b>.  We will see that when events
      are mutually exclusive, the probability that any one of them happens is equal to the sum of their individual probabilities.
    </p>
    
    <p>When there are \(n\) many equally likely outcomes, then the probability of any one of them occurring is
    \[\frac{1}{n}\]
      Since individual outcomes, by their nature, are mutually exclusive, the odds of one of \(x\) many of them happening is
      \[\frac{x}{n}\]
      For instance, if a group of animals consists of 15 dogs, 20 cats, and 3 kangaroos, and an animal is selected at random, let \(X\) be the 
      selected animal.  The probability of selecting a kangaroo is
      \[P(X = \text{kangaroo}) = \frac{3}{38}\]
      since there are 38 equally likely outcomes (the 38 total animals), 3 of which are in the event we are interested in (the 3 kangaroos).  To find 
      the probability that either a cat <b>or</b> a dog is selected, since an animal can't be both a cat and a dog simultaneously, these events are
      mutually exclusive, and
      \[P(X = \text{cat} \cup X = \text{dog}) = P(X = \text{cat}) + P(X = \text{dog}) = \frac{20}{38} + \frac{15}{38} = \frac{35}{38}\]
      The opposite of an event is called its <b>complement</b>.  In the above example, the event of <b>not</b> selecting a kangaroo is the 
      complement of selecting a kangaroo.  The probability of the complement of an event \(E\), denoted \(\overline{E}\) is
      \[P(\overline{E}) = 1 - P(E)\]
      Note that the event of not selecting a kangaroo is the same as the event of selecting a cat or dog.  So,
      \[P(X = \text{cat} \cup X = \text{dog}) = P(\overline{X = \text{kangaroo}}) = 1 - P(X = \text{kangaroo}) = 1 - \frac{3}{38} = \frac{35}{38}\]
      which is exactly the result we obtained using another method.  This happens generally in the study of probability: there are often many ways
      of solving the same problem!
    </p>

      
    <p>Say we want to find the probability of rolling either a 6 or less than a 3, where \(X\) is the outcome of the roll of a 6-sided die.  The two 
      events, "rolling a 6" and "rolling less than 3" are mutually exclusive: they don't overlap.  So,
    \[P(X < 3 \cup X = 6) = P(X < 3) + P(X = 6)\]
    Then, the events of rolling less than a 3 is the same as rolling a 2 or lower, which is the same as rolling a 1 or 2.  So,
    \[P(X < 3) + P(X = 6) = P(X = 1) + P(X = 2) + P(X = 6) = \frac{1}{6} + \frac{1}{6} + \frac{1}{6} = \frac{3}{6} = \frac{1}{2}\]
    </p>


    <p>Things get complicated when we want to find the probability that one of two events will occur when they are not mutually exclusive (they overlap).
      For instance, what is the probability of rolling higher than a 3, or rolling an even number?  The outcomes in this event are
      \[\{2, 4, 5, 6\}\]
      so the probability is
      \[P(X > 3 \cup X = \text{even}) = \frac{4}{6}\]
      However, note that the outcomes in the individual events "rolling higher than a 3" and "rolling an even number" are
      \[\{4, 5, 6\} \text{ and } \{2, 4, 6\}\]
      respectively.  If we were to add the probabilities of those events, we'd get
      \[P(X > 3) + P(X = \text{even}) = \frac{3}{6} + \frac{3}{6} = \frac{6}{6} = 1\]
      which is certainly not true.  The issue here is that we have double-counted the overlap between the two events.  This leads us to the
      inclusion-exclusion princple,
      \[P(E \cup F) = P(E) + P(F) - P(E \cap F)\]
      That is, the overlap between the two events is
      \[P(X > 3 \cap X = \text{even}) = \frac{2}{6}\]
      since there are 2 numbers which are both greater than 3 and even, namely 4 and 6.  Using this information together with the inclusion-exclusion 
      princple, we can now solve the problem:
      \[P(X > 3 \cup X = \text{even}) = P(X > 3) + P(X = \text{even}) - P(X > 3 \cap X = \text{even}) = \frac{3}{6} + \frac{3}{6} - \frac{2}{6} = 
      \frac{4}{6}\]
      which is the same result we obtained previously!
    </p>

    

    <div class="button-container">
      <button id="start-btn" class="rubber-button">Start!</button>
    </div>
    
    <p id="question-text" class="math"></p>

    <div class="button-container">
      <button id="hint-btn" class="rubber-button">Hint</button>
    </div>
    
    <div id="hint-area" class="math" style="margin-top: 1em;"></div>


    <div id="answer-section" style="margin-top: 20px; text-align: center;">
      <label for="user-answer">Enter your answer:</label>
      <input type="text" id="user-answer" />
      <button id="check-answer-btn" class="rubber-button" style="margin-left: 0.5em;">Check Answer</button>
      <p id="answer-feedback" style="font-weight: bold; margin-top: 10px;"></p>
    </div>

  </main>
  <script>
  const hintBtn = document.getElementById('hint-btn');
  const hintArea = document.getElementById('hint-area');
  let hintSteps = [];
  let hintIndex = 0;

  const startBtn = document.getElementById('start-btn');
  const questionText = document.getElementById('question-text');

  const answerInput = document.getElementById('user-answer');
  const feedback = document.getElementById('answer-feedback');

  // Current correct answer stored as a reduced fraction num/den
  let currentAnsNum = null;
  let currentAnsDen = null;

  // -----------------------------
  // Helpers
  // -----------------------------
  function playSound(id) {
    const s = document.getElementById(id);
    if (s) {
      s.currentTime = 0;
      s.play();
    }
  }

  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }

  function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b !== 0) {
      const t = a % b;
      a = b;
      b = t;
    }
    return a === 0 ? 1 : a;
  }

  function reduceFrac(num, den) {
    if (den < 0) { den = -den; num = -num; }
    const g = gcd(num, den);
    return [num / g, den / g];
  }

  function fracToMath(num, den) {
    if (den === 1) return `${num}`;
    return `\\dfrac{${num}}{${den}}`;
  }

  function setAnswer(num, den) {
    const r = reduceFrac(num, den);
    currentAnsNum = r[0];
    currentAnsDen = r[1];
  }

  function resetUIForNewQuestion() {
    feedback.textContent = '';
    feedback.style.color = 'black';
    answerInput.value = '';
    hintArea.innerHTML = '';
    hintSteps = [];
    hintIndex = 0;
  }

  function typeset(elements = []) {
    if (window.MathJax && MathJax.typeset) {
      if (elements.length > 0) MathJax.typeset(elements);
      else MathJax.typeset();
    }
  }

  function parseUserAnswer(raw) {
    // Accept:
    //  - integer: "3"
    //  - fraction: "3/8" (spaces ok)
    //  - decimal: "0.375"
    const s = raw.replace(/\s+/g, '');

    // Fraction a/b
    const fracMatch = s.match(/^([+-]?\d+)\/([+-]?\d+)$/);
    if (fracMatch) {
      const a = parseInt(fracMatch[1], 10);
      const b = parseInt(fracMatch[2], 10);
      if (b === 0) return null;
      return reduceFrac(a, b);
    }

    // Integer
    const intMatch = s.match(/^[+-]?\d+$/);
    if (intMatch) {
      return [parseInt(s, 10), 1];
    }

    // Decimal
    const decMatch = s.match(/^[+-]?\d*\.\d+$/);
    if (decMatch) {
      const sign = s.startsWith('-') ? -1 : 1;
      const t = s.replace('-', '');
      const parts = t.split('.');
      const whole = parts[0] === '' ? 0 : parseInt(parts[0], 10);
      const fracPart = parts[1];
      const den = Math.pow(10, fracPart.length);
      const num = sign * (whole * den + parseInt(fracPart, 10));
      return reduceFrac(num, den);
    }

    return null;
  }

  function isCorrect(userFrac) {
    if (!userFrac || currentAnsNum === null || currentAnsDen === null) return false;
    const [uNum, uDen] = reduceFrac(userFrac[0], userFrac[1]);
    // Exact fraction equality after reduction
    return (uNum === currentAnsNum && uDen === currentAnsDen);
  }

  function letterName(i) {
    // A, B, C, ...
    return String.fromCharCode('A'.charCodeAt(0) + i);
  }

  // -----------------------------
  // Question type 1
  // -----------------------------
  function generateType1() {
    const N = randInt(20, 80);
    const k = randInt(2, 5);

    // Random positive parts summing to N
    let cuts = [];
    for (let i = 0; i < k - 1; i++) cuts.push(randInt(1, N - 1));
    cuts.sort((a, b) => a - b);

    const parts = [];
    let prev = 0;
    for (let i = 0; i < cuts.length; i++) {
      parts.push(cuts[i] - prev);
      prev = cuts[i];
    }
    parts.push(N - prev);

    // Choose between 1 and k-1 pieces
    const m = randInt(1, k - 1);
    const idx = [...Array(k).keys()];
    // shuffle
    for (let i = idx.length - 1; i > 0; i--) {
      const j = randInt(0, i);
      [idx[i], idx[j]] = [idx[j], idx[i]];
    }
    const chosen = idx.slice(0, m).sort((a, b) => a - b);

    const chosenSum = chosen.reduce((acc, i) => acc + parts[i], 0);
    setAnswer(chosenSum, N);

    const pieceLines = parts
      .map((sz, i) => `${letterName(i)}: ${sz}`)
      .join(', ');

    const chosenNames = chosen.map(i => letterName(i)).join(', ');

    questionText.innerHTML =
      `A set has ${N} elements and is partitioned into ${k} mutually exclusive pieces with sizes: ` +
      `\\(${pieceLines}\\). ` +
      `A random element \\(X\\) is chosen from the set. ` +
      `What is \\(P(X\\in ${chosenNames})\\)? ` +
      `(Give your answer as a reduced fraction.)`;

    hintSteps = [
      `Because the pieces are mutually exclusive, you can add probabilities.`,
      `Each piece has probability \\(\\text{size}/ ${N}\\).`,
      `So \\(P(X\\in ${chosenNames}) = \\dfrac{\\text{(sum of chosen sizes)}}{${N}}\\). Reduce if needed.`
    ];

    typeset([questionText]);
  }

  // -----------------------------
  // Question type 2
  // -----------------------------
  function generateType2() {
    const n = randInt(10, 100); // n-sided die
    const r = randInt(2, 5);    // number of disjoint ranges

    // Decide how many "outer" ranges (0,1,2)
    let outerCount = randInt(0, 2);
    // Ensure feasibility: we need room for internal intervals if any
    // We'll build outer ranges using cutpoints a<b, so require n>=3 (true here)
    const hasLowOuter = outerCount >= 1 ? (Math.random() < 0.5) : false;
    const hasHighOuter = outerCount === 2 ? true : (outerCount === 1 ? !hasLowOuter : false);

    // Choose cutpoints for potential outer ranges
    // low outer: X < a  corresponds to outcomes 1..a-1
    // high outer: X >= b corresponds to outcomes b..n
    // Make sure (a-1) and (n-b+1) are positive if used.
    let a = 2;
    let b = n;
    if (hasLowOuter || hasHighOuter) {
      // pick a and b with some slack
      a = randInt(2, Math.max(2, n - 2));      // at least 2
      b = randInt(Math.min(n - 1, a + 1), n);  // at least a+1
      if (b <= a) b = a + 1;
      if (b > n) b = n;
    }

    const intervals = [];
    // Add low outer interval if used
    if (hasLowOuter) {
      intervals.push([1, a - 1]);
    }
    // Add high outer interval if used
    if (hasHighOuter) {
      intervals.push([b, n]);
    }

    // Internal intervals needed
    const internalNeeded = r - intervals.length;
    if (internalNeeded > 0) {
      const L = hasLowOuter ? a : 1;
      const U = hasHighOuter ? (b - 1) : n;
      const span = U - L + 1;

      // If span is too small, fall back to just using outer ranges or fewer internals
      // (but keep r as requested by spec — so we’ll adjust by making sure span works)
      // Since n is at least 10, this should almost always work.
      const picks = [];
      // pick 2*internalNeeded cutpoints in [L,U]
      while (picks.length < 2 * internalNeeded) {
        const x = randInt(L, U);
        if (!picks.includes(x)) picks.push(x);
      }
      picks.sort((x, y) => x - y);

      for (let i = 0; i < picks.length; i += 2) {
        let s = picks[i];
        let t = picks[i + 1];
        if (t < s) [s, t] = [t, s];
        intervals.push([s, t]);
      }
    }

    // Clean up: sort intervals and ensure disjointness (they should be, but just in case)
    intervals.sort((I, J) => I[0] - J[0]);
    // Merge any overlaps (rare) into disjoint by trimming
    const disjoint = [];
    for (const [s, t] of intervals) {
      if (disjoint.length === 0) {
        disjoint.push([s, t]);
      } else {
        const last = disjoint[disjoint.length - 1];
        if (s > last[1]) {
          disjoint.push([s, t]);
        } else {
          // overlap: trim this interval to start after last end, if possible
          const ns = last[1] + 1;
          if (ns <= t) disjoint.push([ns, t]);
        }
      }
    }

    // If we ended up with fewer than r intervals due to trimming, pad with tiny disjoint intervals
    // in gaps (best-effort, but should be extremely rare).
    while (disjoint.length < r) {
      // find a gap
      disjoint.sort((I, J) => I[0] - J[0]);
      let placed = false;
      let prevEnd = 0;
      for (const [s, t] of disjoint) {
        if (s - prevEnd >= 2) { // gap has at least 1 integer
          disjoint.push([prevEnd + 1, prevEnd + 1]);
          placed = true;
          break;
        }
        prevEnd = t;
      }
      if (!placed && prevEnd < n) {
        disjoint.push([prevEnd + 1, prevEnd + 1]);
      }
      if (disjoint.length > 10) break; // sanity
    }

    disjoint.sort((I, J) => I[0] - J[0]);
    const finalIntervals = disjoint.slice(0, r);

    // Build event text; convert edge-touching intervals to "outer" forms (up to 2)
    let usedOuter = 0;
    const eventStrings = finalIntervals.map(([s, t], idx) => {
      if (s === 1 && usedOuter < 2) {
        usedOuter++;
        return `X < ${t + 1}`;
      }
      if (t === n && usedOuter < 2) {
        usedOuter++;
        return `X \\ge ${s}`;
      }
      if (s === t) return `X = ${s}`;
      return `${s} \\le X \\le ${t}`;
    });

    const favorable = finalIntervals.reduce((acc, [s, t]) => acc + (t - s + 1), 0);
    setAnswer(favorable, n);

    questionText.innerHTML =
      `Let \\(X\\) be the outcome of rolling a fair \\(${n}\\)-sided die (outcomes \\(1\\) through \\(${n}\\)). ` +
      `Find \\(P(\\,${eventStrings.join(' \\;\\cup\\; ')}\\,)\\). ` +
      `(Give your answer as a reduced fraction.)`;

    hintSteps = [
      `These ranges are mutually exclusive (disjoint), so probabilities add.`,
      `Each individual outcome has probability \\(\\frac{1}{${n}}\\).`,
      `Count how many outcomes are included in the union, then divide by ${n} and reduce.`
    ];

    typeset([questionText]);
  }

  // -----------------------------
  // Question type 3
  // -----------------------------
  function generateType3() {
    // Work with denominator 100 for easy randoms, then reduce.
    const den = 100;

    let pE = randInt(10, 80);
    let pF = randInt(10, 80);

    // Choose an intersection in the valid range:
    // max(0, pE+pF-100) <= pInt <= min(pE,pF)
    const minInt = Math.max(0, pE + pF - den);
    const maxInt = Math.min(pE, pF);
    let pInt = randInt(minInt, maxInt);

    const pUnion = pE + pF - pInt; // in [0,100]

    // Randomly decide which is given: union or intersection
    const giveUnion = Math.random() < 0.5;

    if (giveUnion) {
      // ask for intersection
      setAnswer(pInt, den);
      questionText.innerHTML =
        `Events \\(E\\) and \\(F\\) satisfy: ` +
        `\\(P(E) = ${fracToMath(...reduceFrac(pE, den))}\\), ` +
        `\\(P(F) = ${fracToMath(...reduceFrac(pF, den))}\\), and ` +
        `\\(P(E \\cup F) = ${fracToMath(...reduceFrac(pUnion, den))}\\). ` +
        `Find \\(P(E \\cap F)\\). (Reduced fraction.)`;

      hintSteps = [
        `Use inclusion-exclusion: \\(P(E\\cup F)=P(E)+P(F)-P(E\\cap F)\\).`,
        `Rearrange: \\(P(E\\cap F)=P(E)+P(F)-P(E\\cup F)\\).`,
        `Substitute and reduce.`
      ];
    } else {
      // ask for union
      setAnswer(pUnion, den);
      questionText.innerHTML =
        `Events \\(E\\) and \\(F\\) satisfy: ` +
        `\\(P(E) = ${fracToMath(...reduceFrac(pE, den))}\\), ` +
        `\\(P(F) = ${fracToMath(...reduceFrac(pF, den))}\\), and ` +
        `\\(P(E \\cap F) = ${fracToMath(...reduceFrac(pInt, den))}\\). ` +
        `Find \\(P(E \\cup F)\\). (Reduced fraction.)`;

      hintSteps = [
        `Use inclusion-exclusion: \\(P(E\\cup F)=P(E)+P(F)-P(E\\cap F)\\).`,
        `Substitute the given probabilities.`,
        `Reduce the resulting fraction.`
      ];
    }

    typeset([questionText]);
  }

  // -----------------------------
  // Question type 4
  // -----------------------------
  function generateType4() {
    const N = randInt(50, 500);

    // Choose subset sizes
    let a = randInt(5, Math.floor(0.8 * N));
    let b = randInt(5, Math.floor(0.8 * N));

    // Decide whether we give union or intersection
    const giveUnion = Math.random() < 0.5;

    if (giveUnion) {
      // union size must be between max(a,b) and min(N, a+b)
      const uMin = Math.max(a, b);
      const uMax = Math.min(N, a + b);
      const u = randInt(uMin, uMax);
      const inter = a + b - u;

      // ask for probability of intersection
      setAnswer(inter, N);

      questionText.innerHTML =
        `A population has \\(${N}\\) members. ` +
        `Subset \\(E\\) has \\(${a}\\) members and subset \\(F\\) has \\(${b}\\) members. ` +
        `Also, \\(|E\\cup F| = ${u}\\). ` +
        `If a person is selected uniformly at random, what is ` +
        `\\(P(\\text{person} \\in E\\cap F)\\)? (Reduced fraction.)`;

      hintSteps = [
        `Use the counting version of inclusion-exclusion: \\(|E\\cup F| = |E|+|F|-|E\\cap F|\\).`,
        `Solve for \\(|E\\cap F|\\): \\(|E\\cap F|=|E|+|F|-|E\\cup F|\\).`,
        `Then probability is \\(\\dfrac{|E\\cap F|}{${N}}\\). Reduce.`
      ];
    } else {
      // intersection size must be between max(0,a+b-N) and min(a,b)
      const iMin = Math.max(0, a + b - N);
      const iMax = Math.min(a, b);
      const inter = randInt(iMin, iMax);
      const u = a + b - inter;

      // ask for probability of union
      setAnswer(u, N);

      questionText.innerHTML =
        `A population has \\(${N}\\) members. ` +
        `Subset \\(E\\) has \\(${a}\\) members and subset \\(F\\) has \\(${b}\\) members. ` +
        `Also, \\(|E\\cap F| = ${inter}\\). ` +
        `If a person is selected uniformly at random, what is ` +
        `\\(P(\\text{person} \\in E\\cup F)\\)? (Reduced fraction.)`;

      hintSteps = [
        `Use inclusion-exclusion (counts): \\(|E\\cup F| = |E|+|F|-|E\\cap F|\\).`,
        `Compute \\(|E\\cup F|\\), then divide by \\(${N}\\).`,
        `Reduce the fraction.`
      ];
    }

    typeset([questionText]);
  }

  // -----------------------------
  // Start: generate a question
  // -----------------------------
  startBtn.addEventListener('click', () => {
    playSound('click-sound');
    resetUIForNewQuestion();

    const qType = randInt(1, 4);

    if (qType === 1) generateType1();
    if (qType === 2) generateType2();
    if (qType === 3) generateType3();
    if (qType === 4) generateType4();
  });

  // -----------------------------
  // Check answer (listener attached ONCE)
  // -----------------------------
  document.getElementById('check-answer-btn').addEventListener('click', () => {
    playSound('click-sound');

    const raw = answerInput.value.trim();
    if (!raw) {
      feedback.textContent = 'Please enter an answer.';
      feedback.style.color = 'black';
      return;
    }

    const parsed = parseUserAnswer(raw);
    if (!parsed) {
      feedback.textContent = 'I couldn’t parse that. Use a reduced fraction like 3/8 (or a decimal).';
      feedback.style.color = 'black';
      return;
    }

    if (isCorrect(parsed)) {
      feedback.textContent = 'Correct!';
      feedback.style.color = 'green';
    } else {
      const correctMath = fracToMath(currentAnsNum, currentAnsDen);
      feedback.innerHTML = `Not quite. Correct answer: \\(${correctMath}\\).`;
      feedback.style.color = 'crimson';
      typeset([feedback]);
    }
  });

  // -----------------------------
  // Hint button (listener attached ONCE)
  // -----------------------------
  hintBtn.addEventListener('click', () => {
    playSound('click-sound');

    if (!hintSteps || hintSteps.length === 0) {
      const hintPara = document.createElement('div');
      hintPara.classList.add('hint-step');
      hintPara.textContent = 'No hints are available for this question.';
      hintArea.appendChild(hintPara);
      typeset([hintPara]);
      return;
    }

    if (hintIndex < hintSteps.length) {
      const hintPara = document.createElement('div');
      hintPara.classList.add('hint-step');
      hintPara.innerHTML = hintSteps[hintIndex];
      hintArea.appendChild(hintPara);
      typeset([hintPara]);
      hintIndex++;
    }
  });
</script>

  <audio id="click-sound" src="button.mp3" preload="auto"></audio>
  <audio id="set-sound" src="set2.mp3" preload="auto"></audio>

</body>
</html>
