<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Personal website of Ben Fraser, with math education activities for students and teachers.">
  <meta charset="UTF-8" />
  <title>Probability III Activity</title>
  <link rel="stylesheet" href="/style.css" />

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>Probability III Activity</h1>
    <div id="nav-placeholder"></div>
      <script>
fetch("/nav.html")
  .then(response => response.text())
  .then(html => {
    document.getElementById("nav-placeholder").innerHTML = html;

    const currentPath = window.location.pathname.replace(/\/index\.html$/, "/");
    const navLinks = document.querySelectorAll("#nav-placeholder a");
    navLinks.forEach(link => {
      const linkPath = new URL(link.href).pathname.replace(/\/index\.html$/, "/");
      if (linkPath === currentPath) {
        link.classList.add("active");
      }
    });

    const s = document.createElement("script");
    s.src = "/mascot.js";
    s.defer = true;
    document.body.appendChild(s); 
  })
  .catch(err => {
    console.error("Failed to load nav:", err);
  });
</script>
  </header>
  <main>

    <p>In our final activity, we tackle conditional probability and Bayes' Theorem.  We have already dealt with conditional probability in the last 
      activity, although somewhat implicitly.  The "multiplying down the branches" of a tree diagram to get the "AND" probabilities was using the 
      <b>multiplication rule</b>,
      \[P(E \cap F) = P(E) \cdot P(F|E)\]
      That is, the probability that both \(E\) and \(F\) happen is the product of the probability that \(E\) happens with the probability that \(F\) 
      happens <i>given that</i> \(E\) has happened.  In the "without replacement" urn example, we saw that the probabilities on our second draw 
      <b>depended</b> on what happened on the first draw.  That is, \(F\) <b>depended</b> on \(E\):
    </p>

    <figure style="text-align: center;">
      <img src="fig11.png"
           alt="Without replacement urn example"
           style="display: inline-block; width: 30%;">
    </figure>
    
    <p>In the "with replacement" urn example, we had that the second draw <b>did not depend</b> on what happened on the first draw.  That is, \(E\) 
      and \(F\) were <b>independent events</b>, so
      \[P(F|E) = P(F)\]
      which simplifies the multiplication rule to
      \[P(E \cap F) = P(E) \cdot P(F)\]
      See below that the probabilities on the second branches are the same as those in the first branches in this case:
    </p>

    <figure style="text-align: center;">
      <img src="fig12.png"
           alt="With replacement urn example"
           style="display: inline-block; width: 30%;">
    </figure>


    <p>The key idea in computing conditional probabilities is that we are <b>given</b> some additional information, and that reduces the size of the 
      sample space of possible events.  To solve such a problem, our first task is to determine which events comprise that reduced sample space, and 
      to then determine the proportion of that reduced space which the event we are interested in occupies.
    </p>

    <p>For example, in the "without replacement" urn example, if we want to find that probability that our first draw was green <b>given that</b> 
      one of our draws was green, we restrict our attention to the leaves corresponding to at least one green draw (the green circles in the tree 
      diagram below), and then find the proportion of them in which the first draw was green (the ones with blue circles as well):
    </p>

    <figure style="text-align: center;">
      <img src="fig15.png"
           alt="With replacement urn example"
           style="display: inline-block; width: 30%;">
    </figure>

      

    <div class="button-container">
      <button id="start-btn" class="rubber-button">Start!</button>
    </div>
    
    <p id="question-text" class="math"></p>

    <div class="button-container">
      <button id="hint-btn" class="rubber-button">Hint</button>
    </div>
    
    <div id="hint-area" class="math" style="margin-top: 1em; text-align: center"></div>


    <div id="answer-section" style="margin-top: 20px; text-align: center;">
      <label for="user-answer">Enter your answer:</label>
      <input type="text" id="user-answer" />
      <button id="check-answer-btn" class="rubber-button" style="margin-left: 0.5em;">Check Answer</button>
      <p id="answer-feedback" style="font-weight: bold; margin-top: 10px;"></p>
    </div>

  </main>
  <script>
  // =============================
  // Probability II Activity Script
  // =============================

  const startBtn = document.getElementById('start-btn');
  const hintBtn = document.getElementById('hint-btn');
  const checkBtn = document.getElementById('check-answer-btn');

  const questionText = document.getElementById('question-text');
  const hintArea = document.getElementById('hint-area');

  const answerInput = document.getElementById('user-answer');
  const feedback = document.getElementById('answer-feedback');

  let hintSteps = [];
  let hintIndex = 0;

  // Correct answer stored as reduced fraction num/den
  let currentAnsNum = null;
  let currentAnsDen = null;

  // -----------------------------
  // Helpers
  // -----------------------------
  function playSound(id) {
    const s = document.getElementById(id);
    if (s) {
      s.currentTime = 0;
      s.play();
    }
  }

  function typeset(elements = []) {
    if (!window.MathJax) return;
    if (MathJax.typesetPromise) {
      if (elements.length > 0) MathJax.typesetPromise(elements);
      else MathJax.typesetPromise();
      return;
    }
    if (MathJax.typeset) {
      if (elements.length > 0) MathJax.typeset(elements);
      else MathJax.typeset();
    }
  }

  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = randInt(0, i);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b !== 0) {
      const t = a % b;
      a = b;
      b = t;
    }
    return a === 0 ? 1 : a;
  }

  function reduceFrac(num, den) {
    if (den < 0) { den = -den; num = -num; }
    const g = gcd(num, den);
    return [num / g, den / g];
  }

  function setAnswer(num, den) {
    const r = reduceFrac(num, den);
    currentAnsNum = r[0];
    currentAnsDen = r[1];
  }

  // IMPORTANT: In JS strings, "\f" is a real escape. To produce TeX "\frac",
  // we must place "\\frac" inside a template literal.
  function fracTex(num, den) {
    const r = reduceFrac(num, den);
    const n = r[0], d = r[1];
    if (d === 1) return `${n}`;
    return `\\frac{${n}}{${d}}`;
  }

  function resetUIForNewQuestion() {
    feedback.textContent = '';
    feedback.style.color = 'black';
    answerInput.value = '';
    hintArea.innerHTML = '';
    hintSteps = [];
    hintIndex = 0;
  }

  function parseUserAnswer(raw) {
    // Accept:
    //  - integer: "3"
    //  - fraction: "3/8"
    //  - decimal: "0.375"
    // Decimals graded with relative tolerance 0.01%.
    const s = raw.replace(/\s+/g, '');

    const fracMatch = s.match(/^([+-]?\d+)\/([+-]?\d+)$/);
    if (fracMatch) {
      const a = parseInt(fracMatch[1], 10);
      const b = parseInt(fracMatch[2], 10);
      if (b === 0) return { error: 'Denominator cannot be 0.' };
      const [rn, rd] = reduceFrac(a, b);
      return { kind: 'exact', num: rn, den: rd };
    }

    const intMatch = s.match(/^[+-]?\d+$/);
    if (intMatch) {
      const a = parseInt(s, 10);
      return { kind: 'exact', num: a, den: 1 };
    }

    const decMatch = s.match(/^[+-]?\d*\.\d+$/);
    if (decMatch) {
      const value = Number(s);
      if (!Number.isFinite(value)) return { error: 'That decimal does not look valid.' };
      if (value < 0) return { error: 'Probabilities cannot be negative.' };
      return { kind: 'decimal', value, relTol: 0.0001 };
    }

    return { error: 'I couldn’t parse that. Use a fraction like 3/8 or a decimal like 0.375.' };
  }

  function isCorrect(parsed) {
    if (currentAnsNum === null || currentAnsDen === null) return false;
    const correctVal = currentAnsNum / currentAnsDen;

    if (!parsed || parsed.error) return false;

    if (parsed.kind === 'exact') {
      const [uNum, uDen] = reduceFrac(parsed.num, parsed.den);
      return (uNum === currentAnsNum && uDen === currentAnsDen);
    }

    if (parsed.kind === 'decimal') {
      const denom = Math.max(1e-12, Math.abs(correctVal));
      return Math.abs(parsed.value - correctVal) <= parsed.relTol * denom;
    }

    return false;
  }

  function joinWithAnd(items) {
    if (items.length === 1) return items[0];
    if (items.length === 2) return `${items[0]} and ${items[1]}`;
    return `${items.slice(0, -1).join(', ')}, and ${items[items.length - 1]}`;
  }

  function singularize(word) {
    if (word.endsWith('s')) return word.slice(0, -1);
    return word;
  }

  function articleFor(word) {
    const first = word[0];
    const vowelLetter = /^[aeiou]/i.test(first);
    const anInitialism = /^[FHLMNRSX]/.test(first);
    return (vowelLetter || anInitialism) ? 'an' : 'a';
  }


// -----------------------------
// Tree diagram helpers (inline SVG)
// -----------------------------
function escHtml(s) {
  return String(s)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}

function svgLine(x1, y1, x2, y2) {
  return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#222" stroke-width="1.5" />`;
}

function svgText(x, y, s, opts = {}) {
  const { anchor = "middle", size = 13, weight = 500, color = "#111", rotate = 0 } = opts;
  const transform = (rotate && rotate !== 0) ? ` transform="rotate(${rotate} ${x} ${y})"` : "";
  return `<text x="${x}" y="${y}" text-anchor="${anchor}" dominant-baseline="middle"${transform}
                font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif"
                font-size="${size}" font-weight="${weight}" fill="${color}">${escHtml(s)}</text>`;
}

function wrapSvg(width, height, inner) {
  return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}"
               xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Tree diagram">${inner}</svg>`;
}

function treeHintHtml(title, svg) {
  return `
    <div style="margin-top: 10px;">
      <div style="font-weight: 600; margin-bottom: 6px;">${escHtml(title)}</div>
      <div style="display: inline-block; border: 1px solid #ddd; border-radius: 10px; padding: 10px; background: #fff;">
        ${svg}
      </div>
    </div>
  `;
}

function fracPlain(n, d) {
  const r = reduceFrac(n, d);
  const rn = r[0], rd = r[1];
  return (rd === 1) ? String(rn) : `${rn}/${rd}`;
}

// Type (2): two-draw urn tree, vertical downward, 3rd stage shows unconditional leaf probabilities.
// highlightSet: set of leaf keys {"RR","RG","GR","GG"} to color green.
function buildUrnTreeSVGVertical(R, G, withReplacement, highlightSet) {
  const T = R + G;

  const W = 780, H = 380;
  const y0 = 10, y1 = 55, y2 = 155, y3 = 275;

  const x0 = W / 2;
  const xR = W * 0.28;
  const xG = W * 0.72;

  const dx = 140;
  const xRR = xR - dx/2;
  const xRG = xR + dx/2;
  const xGR = xG - dx/2;
  const xGG = xG + dx/2;

  let inner = "";

  // stage 1
  inner += svgLine(x0, y0, xR, y1 - 14);
  inner += svgLine(x0, y0, xG, y1 - 14);
  inner += svgText(xR, y1, `Red (${fracPlain(R, T)})`);
  inner += svgText(xG, y1, `Green (${fracPlain(G, T)})`);

  // conditional probs for stage 2
  const pR_after_R = withReplacement ? [R, T] : [R - 1, T - 1];
  const pG_after_R = withReplacement ? [G, T] : [G, T - 1];
  const pR_after_G = withReplacement ? [R, T] : [R, T - 1];
  const pG_after_G = withReplacement ? [G, T] : [G - 1, T - 1];

  // stage 2 from red
  inner += svgLine(xR, y1 + 14, xRR, y2 - 14);
  inner += svgLine(xR, y1 + 14, xRG, y2 - 14);
  inner += svgText(xRR, y2, `Red (${fracPlain(pR_after_R[0], pR_after_R[1])})`, { size: 12, weight: 500 });
  inner += svgText(xRG, y2, `Green (${fracPlain(pG_after_R[0], pG_after_R[1])})`, { size: 12, weight: 500 });

  // stage 2 from green
  inner += svgLine(xG, y1 + 14, xGR, y2 - 14);
  inner += svgLine(xG, y1 + 14, xGG, y2 - 14);
  inner += svgText(xGR, y2, `Red (${fracPlain(pR_after_G[0], pR_after_G[1])})`, { size: 12, weight: 500 });
  inner += svgText(xGG, y2, `Green (${fracPlain(pG_after_G[0], pG_after_G[1])})`, { size: 12, weight: 500 });

  const leaves = [
    { key: "RR", x: xRR, first: [R, T], second: pR_after_R, label: "Red then red" },
    { key: "RG", x: xRG, first: [R, T], second: pG_after_R, label: "Red then green" },
    { key: "GR", x: xGR, first: [G, T], second: pR_after_G, label: "Green then red" },
    { key: "GG", x: xGG, first: [G, T], second: pG_after_G, label: "Green then green" },
  ];

  // stage 3: unconditional leaf probs (product)
  for (const leaf of leaves) {
    inner += svgLine(leaf.x, y2 + 14, leaf.x, y3 - 14);
    const num = leaf.first[0] * leaf.second[0];
    const den = leaf.first[1] * leaf.second[1];
    const frac = fracPlain(num, den);
    const green = (highlightSet && highlightSet.has(leaf.key));
    inner += svgText(leaf.x, y3, `${leaf.label} (${frac})`, { size: 11, weight: green ? 700 : 500, color: green ? "#0a7a21" : "#111", rotate: -30, anchor: "middle" });
  }

  return wrapSvg(W, H, inner);
}

// Type (4): partition + property tree, vertical downward, with a third stage showing unconditional leaf probs.
// highlight(i, which): returns true if the leaf should be green, where which is "prop" or "not".
function buildPartitionPropTreeSVGVertical(subsetNames, counts, prop, propCounts, highlight) {
  const N = counts.reduce((a,b)=>a+b,0);
  const k = subsetNames.length;

  const W = 1200, H = 400;
  const y0 = 10, y1 = 55, y2 = 155, y3 = 275;

  const x0 = W / 2;

  const xs1 = [];

  const pad = 200;
  if (k === 1) {
    xs1.push(W / 2);
  } else {
    for (let i = 0; i < k; i++) xs1.push(pad + i * ((W - 2 * pad) / (k - 1)));
  }

  let inner = "";

  // stage 1: root to subsets
  for (let i = 0; i < k; i++) {
    inner += svgLine(x0, y0, xs1[i], y1 - 14);
    const name = subsetNames[i][0].toUpperCase() + subsetNames[i].slice(1);
    inner += svgText(xs1[i], y1, `${name} (${fracPlain(counts[i], N)})`, { size: 12, weight: 600 });
  }

  const dx = 140;
  for (let i = 0; i < k; i++) {
    const xProp = xs1[i] - dx/2;
    const xNot  = xs1[i] + dx/2;

    const yes = propCounts[i];
    const no = counts[i] - propCounts[i];

    // stage 2 split
    inner += svgLine(xs1[i], y1 + 14, xProp, y2 - 14);
    inner += svgLine(xs1[i], y1 + 14, xNot,  y2 - 14);

    const propTitle = prop[0].toUpperCase() + prop.slice(1);
    inner += svgText(xProp, y2, `${propTitle} (${fracPlain(yes, counts[i])})`, { size: 12 });
    inner += svgText(xNot,  y2, `Not ${prop} (${fracPlain(no, counts[i])})`, { size: 12 });

    // stage 3 straight down to unconditional leaves
    inner += svgLine(xProp, y2 + 14, xProp, y3 - 14);
    inner += svgLine(xNot,  y2 + 14, xNot,  y3 - 14);

    const base = subsetNames[i];

    const greenProp = highlight ? highlight(i, "prop") : false;
    const greenNot  = highlight ? highlight(i, "not") : false;

    inner += svgText(
      xProp, y3,
      `${propTitle} ${base} (${fracPlain(yes, N)})`,
      { size: 11, weight: greenProp ? 700 : 500, color: greenProp ? "#0a7a21" : "#111", rotate: -30, anchor: "middle" }
    );
    inner += svgText(
      xNot, y3,
      `Not ${prop} ${base} (${fracPlain(no, N)})`,
      { size: 11, weight: greenNot ? 700 : 500, color: greenNot ? "#0a7a21" : "#111", rotate: -30, anchor: "middle" }
    );
  }

  return wrapSvg(W, H, inner);
}

  // -----------------------------
  // Type (1): Independent events
  // -----------------------------
  function makeDieEvent() {
    const sides = randInt(6, 20);
    const mode = randInt(1, 3); // 1 exact, 2 higher than, 3 lower than
    if (mode === 1) {
      const k = randInt(1, sides);
      return { desc: `you roll a ${k} on a ${sides}-sided die`, num: 1, den: sides };
    }
    if (mode === 2) {
      const t = randInt(1, sides - 1);
      const favorable = sides - t;
      return { desc: `you roll higher than ${t} on a ${sides}-sided die`, num: favorable, den: sides };
    }
    const t = randInt(2, sides);
    const favorable = t - 1;
    return { desc: `you roll lower than ${t} on a ${sides}-sided die`, num: favorable, den: sides };
  }

  function makeCoinEvent() {
    const ht = randInt(0, 1) === 0 ? 'heads' : 'tails';
    return { desc: `you flip ${ht}`, num: 1, den: 2 };
  }

  function makeCardEvent() {
    const suits = ['spade', 'heart', 'diamond', 'club'];
    const suitPlural = { spade: 'spades', heart: 'hearts', diamond: 'diamonds', club: 'clubs' };
    const ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

    const kind = randInt(1, 4); // 1 suit, 2 face card, 3 specific card, 4 diamond face card
    if (kind === 1) {
      const s = suits[randInt(0, 3)];
      return { desc: `you draw a ${s}`, num: 13, den: 52 };
    }
    if (kind === 2) {
      return { desc: `you draw a face card`, num: 12, den: 52 };
    }
    if (kind === 3) {
      const r = ranks[randInt(0, ranks.length - 1)];
      const s = suits[randInt(0, 3)];
      const suitName = suitPlural[s];
      const rankName = (r === 'A') ? 'ace' : (r === 'J' ? 'jack' : (r === 'Q' ? 'queen' : (r === 'K' ? 'king' : r)));
      return { desc: `you draw the ${rankName} of ${suitName}`, num: 1, den: 52 };
    }
    return { desc: `you draw a diamond face card`, num: 3, den: 52 };
  }

  function generateType1() {
    const howMany = randInt(2, 3);
    const generators = [makeDieEvent, makeCoinEvent, makeCardEvent];
    const chosen = [];
    shuffle(generators);
    for (let i = 0; i < howMany; i++) chosen.push(generators[i % generators.length]());

    const descs = chosen.map(e => e.desc);
    const num = chosen.reduce((acc, e) => acc * e.num, 1);
    const den = chosen.reduce((acc, e) => acc * e.den, 1);
    setAnswer(num, den);

    questionText.textContent = `What is the probability that ${joinWithAnd(descs)}?`;

    hintSteps = [
      `These are independent experiments, so multiply their probabilities.`,
      `Compute each probability, then multiply: \\(P = ${chosen.map(e => fracTex(e.num, e.den)).join(' \\\cdot ')}\\).`,
      `So the probability is \\(${fracTex(num, den)}\\).`
    ];
  }

  // -----------------------------
  // Type (2): Urn (2 draws)
  // -----------------------------
  function generateType2() {
    const R = randInt(1, 20);
    const G = randInt(1, 20);
    const T = R + G;

    const withReplacement = randInt(0, 1) === 0;
    const returnText = withReplacement ? 'then returned to the urn' : 'then not returned to the urn';

    const color = randInt(0, 1) === 0 ? 'red' : 'green';

    const eventBank = [
      { key: 'atLeastOne', text: `at least one draw is ${color}` },
      { key: 'both',       text: `both draws are ${color}` },
      { key: 'neither',    text: `neither draw is ${color}` },
      { key: 'first',      text: `the first draw is ${color}` },
      { key: 'second',     text: `the second draw is ${color}` },
      { key: 'oneEach',    text: `one red and one green are drawn` }
    ];

    const chosenEvent = eventBank[randInt(0, eventBank.length - 1)];

    let num = 0, den = 1;

    if (withReplacement) {
      const pN = (color === 'red') ? R : G;
      const qN = (color === 'red') ? G : R;

      if (chosenEvent.key === 'both') {
        num = pN * pN; den = T * T;
      } else if (chosenEvent.key === 'neither') {
        num = qN * qN; den = T * T;
      } else if (chosenEvent.key === 'first' || chosenEvent.key === 'second') {
        num = pN; den = T;
      } else if (chosenEvent.key === 'atLeastOne') {
        num = (T * T) - (qN * qN); den = T * T;
      } else if (chosenEvent.key === 'oneEach') {
        num = 2 * R * G; den = T * T;
      }
    } else {
      // without replacement
      if (chosenEvent.key === 'both') {
        if (color === 'red') { num = R * (R - 1); den = T * (T - 1); }
        else { num = G * (G - 1); den = T * (T - 1); }
      } else if (chosenEvent.key === 'neither') {
        if (color === 'red') { num = G * (G - 1); den = T * (T - 1); }
        else { num = R * (R - 1); den = T * (T - 1); }
      } else if (chosenEvent.key === 'first' || chosenEvent.key === 'second') {
        num = (color === 'red') ? R : G; den = T;
      } else if (chosenEvent.key === 'atLeastOne') {
        const nNeither = (color === 'red') ? (G * (G - 1)) : (R * (R - 1));
        const dAll = T * (T - 1);
        num = dAll - nNeither; den = dAll;
      } else if (chosenEvent.key === 'oneEach') {
        num = 2 * R * G; den = T * (T - 1);
      }
    }

    setAnswer(num, den);

    questionText.textContent =
      `An urn contains ${R} red balls and ${G} green balls. ` +
      `If a ball is drawn at random, ${returnText}, and a ball is drawn at random again, ` +
      `what is the probability that ${chosenEvent.text}?`;

    // Updated hints per your specs:
    let exprTex = '';
    if (withReplacement) {
      if (chosenEvent.key === 'both') {
        const p = (color === 'red') ? fracTex(R, T) : fracTex(G, T);
        exprTex = `${p} \\\cdot ${p}`;
      } else if (chosenEvent.key === 'neither') {
        const q = (color === 'red') ? fracTex(G, T) : fracTex(R, T);
        exprTex = `${q} \\\cdot ${q}`;
      } else if (chosenEvent.key === 'first' || chosenEvent.key === 'second') {
        const p = (color === 'red') ? fracTex(R, T) : fracTex(G, T);
        exprTex = `${p}`;
      } else if (chosenEvent.key === 'atLeastOne') {
        const q = (color === 'red') ? fracTex(G, T) : fracTex(R, T);
        exprTex = `1 - (${q} \\\cdot ${q})`;
      } else if (chosenEvent.key === 'oneEach') {
        exprTex = `(${fracTex(R, T)} \\\cdot ${fracTex(G, T)}) + (${fracTex(G, T)} \\\cdot ${fracTex(R, T)})`;
      }

      hintSteps = [
        `Since the first ball drawn was returned, we are in a "with replacement" situation: the probabilities for the second draw are independent of the outcome of the first draw.`,
        `The probabilities in the second branches should be identical to the probabilities in the first branches.`,
        `So, the probability that ${chosenEvent.text} is \\(${exprTex} = ${fracTex(num, den)}\\).`
      ];
    } else {
      if (chosenEvent.key === 'both') {
        if (color === 'red') exprTex = `${fracTex(R, T)} \\\cdot ${fracTex(R - 1, T - 1)}`;
        else exprTex = `${fracTex(G, T)} \\\cdot ${fracTex(G - 1, T - 1)}`;
      } else if (chosenEvent.key === 'neither') {
        if (color === 'red') exprTex = `${fracTex(G, T)} \\\cdot ${fracTex(G - 1, T - 1)}`;
        else exprTex = `${fracTex(R, T)} \\\cdot ${fracTex(R - 1, T - 1)}`;
      } else if (chosenEvent.key === 'first' || chosenEvent.key === 'second') {
        const p = (color === 'red') ? fracTex(R, T) : fracTex(G, T);
        exprTex = `${p}`;
      } else if (chosenEvent.key === 'atLeastOne') {
        let neitherTex = '';
        if (color === 'red') neitherTex = `${fracTex(G, T)} \\\cdot ${fracTex(G - 1, T - 1)}`;
        else neitherTex = `${fracTex(R, T)} \\\cdot ${fracTex(R - 1, T - 1)}`;
        exprTex = `1 - (${neitherTex})`;
      } else if (chosenEvent.key === 'oneEach') {
        exprTex = `(${fracTex(R, T)} \\\cdot ${fracTex(G, T - 1)}) + (${fracTex(G, T)} \\\cdot ${fracTex(R, T - 1)})`;
      }

      hintSteps = [
        `Since the first ball drawn was not returned, we are in a "without replacement" situation: the probabilities for the second draw are dependent on the outcome of the first draw.`,
        `The total number of remaining balls is reduced by one on the second draw.`,
        `So, the probability that ${chosenEvent.text} is \\(${exprTex} = ${fracTex(num, den)}\\).`
      ];
    }


    // Final hint: tree diagram (green leaves are the ones being summed)
    const highlightSet = new Set();
    if (chosenEvent.key === 'both') {
      highlightSet.add(color === 'red' ? 'RR' : 'GG');
    } else if (chosenEvent.key === 'neither') {
      highlightSet.add(color === 'red' ? 'GG' : 'RR');
    } else if (chosenEvent.key === 'oneEach') {
      highlightSet.add('RG'); highlightSet.add('GR');
    } else if (chosenEvent.key === 'first') {
      if (color === 'red') { highlightSet.add('RR'); highlightSet.add('RG'); }
      else { highlightSet.add('GG'); highlightSet.add('GR'); }
    } else if (chosenEvent.key === 'second') {
      if (color === 'red') { highlightSet.add('RR'); highlightSet.add('GR'); }
      else { highlightSet.add('GG'); highlightSet.add('RG'); }
    } else if (chosenEvent.key === 'atLeastOne') {
      const neitherKey = (color === 'red') ? 'GG' : 'RR';
      ['RR','RG','GR','GG'].forEach(k => { if (k !== neitherKey) highlightSet.add(k); });
    }

    hintSteps.push(treeHintHtml(
      withReplacement ? 'Tree diagram (with replacement)' : 'Tree diagram (without replacement)',
      buildUrnTreeSVGVertical(R, G, withReplacement, highlightSet)
    ));
  }

  // -----------------------------
  // Type (3): Two populations, two partitions
  // -----------------------------
  const popBank = [
    { labelSing: 'fruit', labelPlur: 'fruits', items: ['Apples', 'Bananas', 'Oranges', 'Pears'] },
    { labelSing: 'animal', labelPlur: 'animals', items: ['Cats', 'Dogs', 'Birds', 'Bears'] },
    { labelSing: 'musical instrument', labelPlur: 'musical instruments', items: ['Trumpets', 'Flutes', 'Clarinets', 'Tubas'] },
    { labelSing: 'piece of furniture', labelPlur: 'pieces of furniture', items: ['Chairs', 'Tables', 'Couches', 'Beds'] },
    { labelSing: 'utensil', labelPlur: 'utensils', items: ['Forks', 'Spoons', 'Spatulas', 'Whisks'] },
    { labelSing: 'vehicle', labelPlur: 'vehicles', items: ['Sedans', 'Jeeps', 'SUVs', 'Trucks'] },
    { labelSing: 'shape', labelPlur: 'shapes', items: ['Squares', 'Triangles', 'Circles', 'Pentagons'] }
  ];

  function randomPartition(total, k) {
    let cuts = [];
    for (let i = 0; i < k - 1; i++) cuts.push(randInt(1, total - 1));
    cuts.sort((a, b) => a - b);
    const parts = [];
    let prev = 0;
    for (let i = 0; i < cuts.length; i++) { parts.push(cuts[i] - prev); prev = cuts[i]; }
    parts.push(total - prev);
    return parts;
  }

  function generateType3() {
    const idxs = shuffle([0,1,2,3,4,5,6]);
    const popA = popBank[idxs[0]];
    const popB = popBank[idxs[1]];

    const NA = randInt(10, 100);
    const NB = randInt(10, 100);

    const kA = randInt(2, 4);
    const kB = randInt(2, 4);

    const itemsA = shuffle([...popA.items]).slice(0, kA);
    const itemsB = shuffle([...popB.items]).slice(0, kB);

    const countsA = randomPartition(NA, kA);
    const countsB = randomPartition(NB, kB);

    const breakdownA = itemsA.map((it, i) => `${countsA[i]} ${it}`).join(', ');
    const breakdownB = itemsB.map((it, i) => `${countsB[i]} ${it}`).join(', ');

    const pickA = randInt(0, kA - 1);
    const pickB = randInt(0, kB - 1);

    const countFavA = countsA[pickA];
    const countFavB = countsB[pickB];

    const num = countFavA * countFavB;
    const den = NA * NB;
    setAnswer(num, den);

    const aSing = popA.labelSing;
    const bSing = popB.labelSing;

    const aChosen = singularize(itemsA[pickA]);
    const bChosen = singularize(itemsB[pickB]);

    questionText.textContent =
      `There are ${NA} ${popA.labelPlur}, consisting of ${breakdownA}, and ${NB} ${popB.labelPlur}, consisting of ${breakdownB}. ` +
      `If a ${aSing} and a ${bSing} are selected at random, what is the probability that ` +
      `${articleFor(aChosen)} ${aChosen.toLowerCase()} and ${articleFor(bChosen)} ${bChosen.toLowerCase()} are selected?`;

    hintSteps = [
      `The probability of selecting ${articleFor(aChosen)} ${aChosen.toLowerCase()} from ${NA} total ${popA.labelPlur} is \\(${fracTex(countFavA, NA)}\\).`,
      `The probability of selecting ${articleFor(bChosen)} ${bChosen.toLowerCase()} from ${NB} total ${popB.labelPlur} is \\(${fracTex(countFavB, NB)}\\).`,
      `Selections are independent, so multiply: \\(${fracTex(countFavA, NA)} \\\cdot ${fracTex(countFavB, NB)} = ${fracTex(num, den)}\\).`
    ];
  }

  // -----------------------------
  // Type (4): One population, partition + property rates
  // -----------------------------
  const propertyByCategory = {
    'fruit': 'rotten',
    'animal': 'rabid',
    'musical instrument': 'brass',
    'piece of furniture': 'antique',
    'utensil': 'silver',
    'vehicle': 'electric',
    'shape': 'blue'
  };

  function generateType4() {
    const pop = popBank[randInt(0, popBank.length - 1)];
    const prop = propertyByCategory[pop.labelSing];

    const N = randInt(10, 100);
    const k = randInt(2, 4);

    const items = shuffle([...pop.items]).slice(0, k);
    const counts = randomPartition(N, k);

    const propCounts = [];
    for (let i = 0; i < k; i++) {
      const p = randInt(1, 99);
      let c = Math.round(counts[i] * p / 100);
      c = Math.max(0, Math.min(counts[i], c));
      propCounts.push(c);
    }

    const breakdown = items.map((it, i) => `${counts[i]} ${it}`).join(', ');
    const propertyLines = items.map((it, i) => `${propCounts[i]} of the ${it.toLowerCase()} are ${prop}.`).join(' ');

    const subtype = randInt(1, 2);
    const isNot = randInt(0, 1) === 0 ? 'is' : "isn't";

    let favorable = 0;
    let targetPhrase = '';

    if (subtype === 1) {
      const totalProp = propCounts.reduce((a, b) => a + b, 0);
      favorable = (isNot === 'is') ? totalProp : (N - totalProp);
      targetPhrase = `${isNot} ${prop}`;
    } else {
      const j = randInt(0, k - 1);
      const subsetSing = singularize(items[j]).toLowerCase();
      const inSubsetProp = propCounts[j];
      const inSubsetNot = counts[j] - propCounts[j];
      favorable = (isNot === 'is') ? inSubsetProp : inSubsetNot;
      targetPhrase = `${isNot} ${prop} and is ${articleFor(subsetSing)} ${subsetSing}`;
    }

    setAnswer(favorable, N);

    questionText.textContent =
      `There are ${N} ${pop.labelPlur}, consisting of ${breakdown}. ` +
      `${propertyLines} ` +
      `What is the probability that a randomly selected ${pop.labelSing} ${targetPhrase}?`;

    const subsetNames = items.map(x => x.toLowerCase());
    const subsetList = (subsetNames.length === 2)
      ? `${subsetNames[0]} and ${subsetNames[1]}`
      : `${subsetNames.slice(0, -1).join(', ')}, and ${subsetNames[subsetNames.length - 1]}`;

    let sumTex = '';
    if (subtype === 1) {
      const terms = items.map((_, i) => {
        const first = `${fracTex(counts[i], N)}`;
        const second = (isNot === 'is')
          ? `${fracTex(propCounts[i], counts[i])}`
          : `${fracTex(counts[i] - propCounts[i], counts[i])}`;
        return `(${first} \\\cdot ${second})`;
      });
      sumTex = terms.join(' + ');
    } else {
      // single branch
      let jj = 0;
      for (let i = 0; i < k; i++) {
        const cand = (isNot === 'is') ? propCounts[i] : (counts[i] - propCounts[i]);
        if (cand === favorable) { jj = i; break; }
      }
      const first = `${fracTex(counts[jj], N)}`;
      const second = (isNot === 'is') ? `${fracTex(propCounts[jj], counts[jj])}` : `${fracTex(counts[jj] - propCounts[jj], counts[jj])}`;
      sumTex = `(${first} \\\cdot ${second})`;
    }

    hintSteps = [
      `The ${pop.labelPlur} are partitioned into ${subsetList}. So this gives us the probabilities for the first branch of a tree diagram.`,
      `Each of the subsets in the partition are either ${prop} or not ${prop}. So each of the nodes at the first level branch off twice at the second stage.`,
      `Multiply the probabilities down the branches to find the probabilities of the "AND" events.`,
      `Sum the probabilities of the events that make up the situation we are interested in: \\(${sumTex}\\).`
    ];


    // Final hint: tree diagram (green leaves are the ones being summed)
    const highlight = (i, which) => {
      if (subtype === 1) {
        return (isNot === 'is') ? (which === 'prop') : (which === 'not');
      }
      // property AND a specific subset: highlight only that subset's relevant leaf
      let jj = 0;
      for (let t = 0; t < k; t++) {
        const cand = (isNot === 'is') ? propCounts[t] : (counts[t] - propCounts[t]);
        if (cand === favorable) { jj = t; break; }
      }
      if (i !== jj) return false;
      return (isNot === 'is') ? (which === 'prop') : (which === 'not');
    };

    hintSteps.push(treeHintHtml(
      'Tree diagram',
      buildPartitionPropTreeSVGVertical(subsetNames, counts, prop, propCounts, highlight)
    ));
  }

  // -----------------------------
  // Start button
  // -----------------------------
  startBtn.addEventListener('click', () => {
    playSound('click-sound');
    resetUIForNewQuestion();

    const qType = randInt(1, 4);
    if (qType === 1) generateType1();
    if (qType === 2) generateType2();
    if (qType === 3) generateType3();
    if (qType === 4) generateType4();

    typeset([questionText]);
  });

  // -----------------------------
  // Hint button
  // -----------------------------
  hintBtn.addEventListener('click', () => {
    playSound('click-sound');

    if (!hintSteps || hintSteps.length === 0) {
      const hintPara = document.createElement('div');
      hintPara.classList.add('hint-step');
      hintPara.style.textAlign = 'center';
      hintPara.textContent = 'No hints are available for this question.';
      hintArea.appendChild(hintPara);
      typeset([hintPara]);
      return;
    }

    if (hintIndex < hintSteps.length) {
      const hintPara = document.createElement('div');
      hintPara.classList.add('hint-step');
      hintPara.style.textAlign = 'center';
      hintPara.innerHTML = hintSteps[hintIndex];
      hintArea.appendChild(hintPara);
      typeset([hintPara]);
      hintIndex++;
    }
  });

  // -----------------------------
  // Check answer
  // -----------------------------
  checkBtn.addEventListener('click', () => {
    playSound('click-sound');

    const raw = answerInput.value.trim();
    if (!raw) {
      feedback.textContent = 'Please enter an answer.';
      feedback.style.color = 'black';
      return;
    }

    const parsed = parseUserAnswer(raw);
    if (parsed.error) {
      feedback.textContent = parsed.error;
      feedback.style.color = 'black';
      return;
    }

    if (isCorrect(parsed)) {
      feedback.textContent = 'Correct!';
      feedback.style.color = 'green';
    } else {
      const exact = `${currentAnsNum}/${currentAnsDen}`;
      const dec = (currentAnsNum / currentAnsDen).toFixed(6).replace(/0+$/, '').replace(/\.$/, '');
      feedback.textContent = `Not quite. Correct answer is ${exact} (≈ ${dec}).`;
      feedback.style.color = 'crimson';
    }
  });
</script>



  <audio id="click-sound" src="button.mp3" preload="auto"></audio>
  <audio id="set-sound" src="set2.mp3" preload="auto"></audio>

</body>
</html>
