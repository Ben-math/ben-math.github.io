
<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Personal website of Ben Fraser, with math education activities for students and teachers.">
  <meta charset="UTF-8" />
  <title>Probability III Activity</title>
  <link rel="stylesheet" href="/style.css" />

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>Probability III Activity</h1>
    <div id="nav-placeholder"></div>
      <script>
fetch("/nav.html")
  .then(response => response.text())
  .then(html => {
    document.getElementById("nav-placeholder").innerHTML = html;

    const currentPath = window.location.pathname.replace(/\/index\.html$/, "/");
    const navLinks = document.querySelectorAll("#nav-placeholder a");
    navLinks.forEach(link => {
      const linkPath = new URL(link.href).pathname.replace(/\/index\.html$/, "/");
      if (linkPath === currentPath) {
        link.classList.add("active");
      }
    });

    const s = document.createElement("script");
    s.src = "/mascot.js";
    s.defer = true;
    document.body.appendChild(s); 
  })
  .catch(err => {
    console.error("Failed to load nav:", err);
  });
</script>
  </header>
  <main>

    <p>In our final activity, we tackle conditional probability and Bayes' Theorem.  We have already dealt with conditional probability in the last 
      activity, although somewhat implicitly.  The "multiplying down the branches" of a tree diagram to get the "AND" probabilities was using the 
      <b>multiplication rule</b>,
      \[P(E \cap F) = P(E) \cdot P(F|E)\]
      That is, the probability that both \(E\) and \(F\) happen is the product of the probability that \(E\) happens with the probability that \(F\) 
      happens <i>given that</i> \(E\) has happened.  In the "without replacement" urn example, we saw that the probabilities on our second draw 
      <b>depended</b> on what happened on the first draw.  That is, \(F\) <b>depended</b> on \(E\):
    </p>

    <figure style="text-align: center;">
      <img src="fig12.png"
           alt="Without replacement urn example"
           style="display: inline-block; width: 30%;">
    </figure>
    
    <p>In the "with replacement" urn example, we had that the second draw <b>did not depend</b> on what happened on the first draw.  That is, \(E\) 
      and \(F\) were <b>independent events</b>, so
      \[P(F|E) = P(F)\]
      which simplifies the multiplication rule to
      \[P(E \cap F) = P(E) \cdot P(F)\]
      See below that the probabilities on the second branches are the same as those in the first branches in this case:
    </p>

    <figure style="text-align: center;">
      <img src="fig11.png"
           alt="With replacement urn example"
           style="display: inline-block; width: 30%;">
    </figure>


    <p>The key idea in computing conditional probabilities is that we are <b>given</b> some additional information, and that reduces the size of the 
      sample space of possible events.  To solve such a problem, our first task is to determine which events comprise that reduced sample space, and 
      to then determine the proportion of that reduced space which the event we are interested in occupies.
    </p>

    <p>For example, in the "without replacement" urn example, if we want to find that probability that our first draw was green <b>given that</b> 
      one of our draws was green (let us call this event \(E\), we restrict our attention to the leaves corresponding to at least one green draw 
      (the green circles in the tree diagram below), and then find the proportion of them in which the first draw was green (the ones with blue 
      circles as well):
    </p>

    <figure style="text-align: center;">
      <img src="fig15.png"
           alt="With replacement urn example"
           style="display: inline-block; width: 30%;">
    </figure>

    <p>\[P(G_1|E) = P(((G_1 \cap R_2) \cup (G_1 \cap G_2))|E) =  \frac{P(G_1 \cap R_2) + P(G_1 \cap G_2)}{P(R_1 \cap G_2) + P(G_1 \cap R_2) + 
      P(G_1 \cap G_2)} = \frac{\frac{24}{90} + \frac{30}{90}}{\frac{24}{90} + \frac{24}{90} + \frac{30}{90}} = \frac{54}{78} = \frac{9}{13}\]</p>

    <p>Since the preceding is the sort of question we often want to answer, we have a special name for a narrow case of it.  Let \(F_1\),... \(F_n\) be 
      a partition of a sample space \(S\).  We saw previously the Law of Total Probability,
      \[P(E) = P(F_1) \cdot P(E|F_1) + P(F_2) \cdot P(E|F_2) + ... + P(F_n) \cdot P(E|F_n)\]
      A related question is to find \(P(F_i|E)\).  Rearranging the multiplication rule, we obtain Bayes' Theorem:
      \[P(F_i|E) = \frac{P(F_i \cap E)}{P(E)} = \frac{P(F_i) \cdot P(E|F_i)}{P(F_1) \cdot P(E|F_1) + P(F_2) \cdot P(E|F_2) + ... + P(F_n) \cdot P(E|F_n)}\]
      In the sushi example from the previous activity, to find the probability that a person is a nurse <b>given that</b> they like sushi, we enter the 
      reduced sample space of people who like sushi (via the Law of Total Probability): this will be our denominator.  Then our numerator, the event we're 
      interested in, is the nurses who like sushi: this is our numerator:
      \[P(N|S) = \frac{P(N) \cdot P(S|N)}{P(A) \cdot P(S|A) + P(T) \cdot P(S|T) + P(N) \cdot P(S|N)} = \frac{\frac{7}{100}}{\frac{30}{100} + 
      \frac{20}{100} + \frac{7}{100}} = \frac{7}{57}\]
    </p>

    <figure style="text-align: center;">
      <img src="fig16.png"
           alt="Bayes' Theorem example"
           style="display: inline-block; width: 30%;">
    </figure>
      

    <div class="button-container">
      <button id="start-btn" class="rubber-button">Start!</button>
    </div>
    
    <p id="question-text" class="math"></p>

    <div class="button-container">
      <button id="hint-btn" class="rubber-button">Hint</button>
    </div>
    
    <div id="hint-area" class="math" style="margin-top: 1em; text-align: center"></div>


    <div id="answer-section" style="margin-top: 20px; text-align: center;">
      <label for="user-answer">Enter your answer:</label>
      <input type="text" id="user-answer" />
      <button id="check-answer-btn" class="rubber-button" style="margin-left: 0.5em;">Check Answer</button>
      <p id="answer-feedback" style="font-weight: bold; margin-top: 10px;"></p>
    </div>

  </main>
  <script>
  // =============================
  // Probability III Activity Script
  // Conditional probability (Urns + Bayes/Tree)
  // =============================

  const startBtn = document.getElementById('start-btn');
  const hintBtn = document.getElementById('hint-btn');
  const checkBtn = document.getElementById('check-answer-btn');

  const questionText = document.getElementById('question-text');
  const hintArea = document.getElementById('hint-area');

  const answerInput = document.getElementById('user-answer');
  const feedback = document.getElementById('answer-feedback');

  let hintSteps = [];
  let hintIndex = 0;

  // Correct answer stored as reduced fraction num/den
  let currentAnsNum = null;
  let currentAnsDen = null;

  // -----------------------------
  // Helpers
  // -----------------------------
  function playSound(id) {
    const s = document.getElementById(id);
    if (s) { s.currentTime = 0; s.play(); }
  }

  function typeset(elements = []) {
    if (!window.MathJax) return;
    if (MathJax.typesetPromise) {
      if (elements.length > 0) MathJax.typesetPromise(elements);
      else MathJax.typesetPromise();
      return;
    }
    if (MathJax.typeset) {
      if (elements.length > 0) MathJax.typeset(elements);
      else MathJax.typeset();
    }
  }

  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = randInt(0, i);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b !== 0) { const t = a % b; a = b; b = t; }
    return a === 0 ? 1 : a;
  }

  function reduceFrac(num, den) {
    if (den < 0) { den = -den; num = -num; }
    const g = gcd(num, den);
    return [num / g, den / g];
  }

  function setAnswer(num, den) {
    const r = reduceFrac(num, den);
    currentAnsNum = r[0];
    currentAnsDen = r[1];
  }

  // IMPORTANT: In JS strings, "\f" is a real escape. To produce TeX "\frac",
  // we must place "\\frac" inside a template literal.
  function fracTex(num, den) {
    const r = reduceFrac(num, den);
    const n = r[0], d = r[1];
    if (d === 1) return `${n}`;
    return `\\frac{${n}}{${d}}`;
  }

  function resetUIForNewQuestion() {
    feedback.textContent = '';
    feedback.style.color = 'black';
    answerInput.value = '';
    hintArea.innerHTML = '';
    hintSteps = [];
    hintIndex = 0;
  }

  function parseUserAnswer(raw) {
    // Accept:
    //  - integer: "3"
    //  - fraction: "3/8"
    //  - decimal: "0.375"
    // Decimals graded with relative tolerance 0.01%.
    const s = raw.replace(/\s+/g, '');

    const fracMatch = s.match(/^([+-]?\d+)\/([+-]?\d+)$/);
    if (fracMatch) {
      const a = parseInt(fracMatch[1], 10);
      const b = parseInt(fracMatch[2], 10);
      if (b === 0) return { error: 'Denominator cannot be 0.' };
      const [rn, rd] = reduceFrac(a, b);
      return { kind: 'exact', num: rn, den: rd };
    }

    const intMatch = s.match(/^[+-]?\d+$/);
    if (intMatch) {
      const a = parseInt(s, 10);
      return { kind: 'exact', num: a, den: 1 };
    }

    const decMatch = s.match(/^[+-]?\d*\.\d+$/);
    if (decMatch) {
      const value = Number(s);
      if (!Number.isFinite(value)) return { error: 'That decimal does not look valid.' };
      if (value < 0) return { error: 'Probabilities cannot be negative.' };
      return { kind: 'decimal', value, relTol: 0.0001 };
    }

    return { error: 'I couldn’t parse that. Use a fraction like 3/8 or a decimal like 0.375.' };
  }

  function isCorrect(parsed) {
    if (currentAnsNum === null || currentAnsDen === null) return false;
    const correctVal = currentAnsNum / currentAnsDen;

    if (!parsed || parsed.error) return false;

    if (parsed.kind === 'exact') {
      const [uNum, uDen] = reduceFrac(parsed.num, parsed.den);
      return (uNum === currentAnsNum && uDen === currentAnsDen);
    }

    if (parsed.kind === 'decimal') {
      const denom = Math.max(1e-12, Math.abs(correctVal));
      return Math.abs(parsed.value - correctVal) <= parsed.relTol * denom;
    }

    return false;
  }

  function singularize(word) {
    if (word.endsWith('s')) return word.slice(0, -1);
    return word;
  }

  function articleFor(word) {
    const first = word[0];
    const vowelLetter = /^[aeiou]/i.test(first);
    const anInitialism = /^[FHLMNRSX]/.test(first);
    return (vowelLetter || anInitialism) ? 'an' : 'a';
  }

  // -----------------------------
  // Tree diagram helpers (inline SVG)
  // -----------------------------
  function escHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function svgLine(x1, y1, x2, y2, stroke = "#222") {
    return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${stroke}" stroke-width="1.5" />`;
  }

  function svgText(x, y, s, opts = {}) {
    const { anchor = "middle", size = 13, weight = 500, color = "#111", rotate = 0 } = opts;
    const transform = (rotate && rotate !== 0) ? ` transform="rotate(${rotate} ${x} ${y})"` : "";
    return `<text x="${x}" y="${y}" text-anchor="${anchor}" dominant-baseline="middle"${transform}
                  font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif"
                  font-size="${size}" font-weight="${weight}" fill="${color}">${escHtml(s)}</text>`;
  }

  function wrapSvg(width, height, inner) {
    return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}"
                 xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Tree diagram">${inner}</svg>`;
  }

  function treeHintHtml(title, svg) {
    return `
      <div style="margin-top: 10px;">
        <div style="font-weight: 600; margin-bottom: 6px;">${escHtml(title)}</div>
        <div style="display: inline-block; border: 1px solid #ddd; border-radius: 10px; padding: 10px; background: #fff;">
          ${svg}
        </div>
      </div>
    `;
  }

  function fracPlain(n, d) {
    const r = reduceFrac(n, d);
    const rn = r[0], rd = r[1];
    return (rd === 1) ? String(rn) : `${rn}/${rd}`;
  }

  function leafColor(key, greenSet, blueSet) {
    if (greenSet && greenSet.has(key)) return "#0a7a21";
    if (blueSet && blueSet.has(key)) return "#1b63c6";
    return "#111";
  }
  function leafWeight(key, greenSet, blueSet) {
    if (greenSet && greenSet.has(key)) return 800;
    if (blueSet && blueSet.has(key)) return 700;
    return 500;
  }

  // Type (2) tree: highlight denominator leaves in blue, numerator leaves in green
  function buildUrnTreeSVGVertical(R, G, withReplacement, greenSet, blueSet) {
    const T = R + G;

    const W = 780, H = 380;
    const y0 = 10, y1 = 55, y2 = 155, y3 = 275;

    const x0 = W / 2;
    const xR = W * 0.28;
    const xG = W * 0.72;

    const dx = 140;
    const xRR = xR - dx/2;
    const xRG = xR + dx/2;
    const xGR = xG - dx/2;
    const xGG = xG + dx/2;

    let inner = "";

    inner += svgLine(x0, y0, xR, y1 - 14);
    inner += svgLine(x0, y0, xG, y1 - 14);
    inner += svgText(xR, y1, `Red (${fracPlain(R, T)})`);
    inner += svgText(xG, y1, `Green (${fracPlain(G, T)})`);

    const pR_after_R = withReplacement ? [R, T] : [R - 1, T - 1];
    const pG_after_R = withReplacement ? [G, T] : [G, T - 1];
    const pR_after_G = withReplacement ? [R, T] : [R, T - 1];
    const pG_after_G = withReplacement ? [G, T] : [G - 1, T - 1];

    inner += svgLine(xR, y1 + 14, xRR, y2 - 14);
    inner += svgLine(xR, y1 + 14, xRG, y2 - 14);
    inner += svgText(xRR, y2, `Red (${fracPlain(pR_after_R[0], pR_after_R[1])})`, { size: 12 });
    inner += svgText(xRG, y2, `Green (${fracPlain(pG_after_R[0], pG_after_R[1])})`, { size: 12 });

    inner += svgLine(xG, y1 + 14, xGR, y2 - 14);
    inner += svgLine(xG, y1 + 14, xGG, y2 - 14);
    inner += svgText(xGR, y2, `Red (${fracPlain(pR_after_G[0], pR_after_G[1])})`, { size: 12 });
    inner += svgText(xGG, y2, `Green (${fracPlain(pG_after_G[0], pG_after_G[1])})`, { size: 12 });

    const leaves = [
      { key: "RR", x: xRR, first: [R, T], second: pR_after_R, label: "Red then red" },
      { key: "RG", x: xRG, first: [R, T], second: pG_after_R, label: "Red then green" },
      { key: "GR", x: xGR, first: [G, T], second: pR_after_G, label: "Green then red" },
      { key: "GG", x: xGG, first: [G, T], second: pG_after_G, label: "Green then green" },
    ];

    for (const leaf of leaves) {
      inner += svgLine(leaf.x, y2 + 14, leaf.x, y3 - 14);
      const num = leaf.first[0] * leaf.second[0];
      const den = leaf.first[1] * leaf.second[1];
      const frac = fracPlain(num, den);
      inner += svgText(
        leaf.x, y3,
        `${leaf.label} (${frac})`,
        {
          size: 11,
          weight: leafWeight(leaf.key, greenSet, blueSet),
          color: leafColor(leaf.key, greenSet, blueSet),
          rotate: -30,
          anchor: "middle"
        }
      );
    }

    return wrapSvg(W, H, inner);
  }

  // Type (4) tree: highlight denominator leaves in blue, numerator leaves in green
  function buildPartitionPropTreeSVGVertical(subsetNames, counts, prop, propCounts, greenLeaves, blueLeaves) {
    const N = counts.reduce((a,b)=>a+b,0);
    const k = subsetNames.length;

    const W = 1300, H = 440;
    const y0 = 10, y1 = 60, y2 = 175, y3 = 320;

    const x0 = W / 2;

    const xs1 = [];
    const pad = 170;
    if (k === 1) xs1.push(W / 2);
    else for (let i = 0; i < k; i++) xs1.push(pad + i * ((W - 2 * pad) / (k - 1)));

    let inner = "";

    for (let i = 0; i < k; i++) {
      inner += svgLine(x0, y0, xs1[i], y1 - 14);
      const name = subsetNames[i][0].toUpperCase() + subsetNames[i].slice(1);
      inner += svgText(xs1[i], y1, `${name} (${fracPlain(counts[i], N)})`, { size: 12, weight: 650 });
    }

    const dx = 130;
    for (let i = 0; i < k; i++) {
      const xProp = xs1[i] - dx/2;
      const xNot  = xs1[i] + dx/2;

      const yes = propCounts[i];
      const no = counts[i] - propCounts[i];

      inner += svgLine(xs1[i], y1 + 14, xProp, y2 - 14);
      inner += svgLine(xs1[i], y1 + 14, xNot,  y2 - 14);

      const propTitle = prop[0].toUpperCase() + prop.slice(1);
      inner += svgText(xProp, y2, `${propTitle} (${fracPlain(yes, counts[i])})`, { size: 12 });
      inner += svgText(xNot,  y2, `Not ${prop} (${fracPlain(no, counts[i])})`, { size: 12 });

      inner += svgLine(xProp, y2 + 14, xProp, y3 - 14);
      inner += svgLine(xNot,  y2 + 14, xNot,  y3 - 14);

      const base = subsetNames[i];
      const keyProp = `S${i}_P`;
      const keyNot  = `S${i}_N`;

      inner += svgText(
        xProp, y3,
        `${propTitle} ${base} (${fracPlain(yes, N)})`,
        { size: 11, weight: leafWeight(keyProp, greenLeaves, blueLeaves), color: leafColor(keyProp, greenLeaves, blueLeaves), rotate: -30, anchor: "middle" }
      );
      inner += svgText(
        xNot, y3,
        `Not ${prop} ${base} (${fracPlain(no, N)})`,
        { size: 11, weight: leafWeight(keyNot, greenLeaves, blueLeaves), color: leafColor(keyNot, greenLeaves, blueLeaves), rotate: -30, anchor: "middle" }
      );
    }

    return wrapSvg(W, H, inner);
  }

  // -----------------------------
  // Event sets for urn leaves
  // -----------------------------
  const urnEventToLeaves = {
    bothRed: new Set(["RR"]),
    bothGreen: new Set(["GG"]),
    firstRed: new Set(["RR","RG"]),
    firstGreen: new Set(["GR","GG"]),
    secondRed: new Set(["RR","GR"]),
    secondGreen: new Set(["RG","GG"]),
    atLeastOneRed: new Set(["RR","RG","GR"]),
    atLeastOneGreen: new Set(["RG","GR","GG"]),
    oneEach: new Set(["RG","GR"]),
    // "first is green" etc are already covered above as firstGreen, secondGreen
  };

  function urnLeafNumerators(R, G, withReplacement) {
    const T = R + G;
    if (withReplacement) {
      const den = T * T;
      return {
        den,
        RR: R * R,
        RG: R * G,
        GR: G * R,
        GG: G * G
      };
    }
    const den = T * (T - 1);
    return {
      den,
      RR: R * (R - 1),
      RG: R * G,
      GR: G * R,
      GG: G * (G - 1)
    };
  }

  function sumLeavesNums(leafNums, leavesSet) {
    let s = 0;
    for (const k of leavesSet) s += leafNums[k];
    return s;
  }

  function urnEventLabel(key) {
    switch (key) {
      case "bothRed": return "both draws are red";
      case "bothGreen": return "both draws are green";
      case "firstRed": return "the first draw is red";
      case "firstGreen": return "the first draw is green";
      case "secondRed": return "the second draw is red";
      case "secondGreen": return "the second draw is green";
      case "atLeastOneRed": return "at least one draw is red";
      case "atLeastOneGreen": return "at least one draw is green";
      case "oneEach": return "one red and one green are drawn";
      default: return key;
    }
  }

  // -----------------------------
  // Type (2): Conditional urn problems
  // -----------------------------
  function generateType2Conditional() {
    const R = randInt(1, 20);
    const G = randInt(1, 20);
    const T = R + G;

    const withReplacement = randInt(0, 1) === 0;
    const returnText = withReplacement ? 'then returned to the urn' : 'then not returned to the urn';

    // Choose a "given" event
    const givenChoices = [];
    // at least one draw is red/green
    givenChoices.push("atLeastOneRed", "atLeastOneGreen");
    // first/second draw is red/green
    givenChoices.push("firstRed","firstGreen","secondRed","secondGreen");
    // one of each
    givenChoices.push("oneEach");

    const givenKey = givenChoices[randInt(0, givenChoices.length - 1)];
    const givenLeaves = new Set(urnEventToLeaves[givenKey]);

    // Choose an asked event as a proper sub-event of the given event, per your rules.
    let askedKey = null;
    if (givenKey === "atLeastOneRed") {
      const options = ["bothRed","firstRed","secondRed","firstGreen","secondGreen"];
      askedKey = options[randInt(0, options.length - 1)];
    } else if (givenKey === "atLeastOneGreen") {
      const options = ["bothGreen","firstRed","secondRed","firstGreen","secondGreen"];
      askedKey = options[randInt(0, options.length - 1)];
    } else if (givenKey === "firstRed") {
      const options = ["bothRed","secondRed","secondGreen"];
      askedKey = options[randInt(0, options.length - 1)];
    } else if (givenKey === "firstGreen") {
      const options = ["bothGreen","secondGreen","secondRed"];
      askedKey = options[randInt(0, options.length - 1)];
    } else if (givenKey === "secondRed") {
      const options = ["bothRed","firstRed","firstGreen"];
      askedKey = options[randInt(0, options.length - 1)];
    } else if (givenKey === "secondGreen") {
      const options = ["bothGreen","firstGreen","firstRed"];
      askedKey = options[randInt(0, options.length - 1)];
    } else if (givenKey === "oneEach") {
      const options = ["firstRed","firstGreen","secondRed","secondGreen"];
      askedKey = options[randInt(0, options.length - 1)];
    }

    const askedLeaves = new Set(urnEventToLeaves[askedKey]);

    // Ensure asked is a subset of given (it should be by construction, but safety anyway)
    for (const lf of askedLeaves) {
      if (!givenLeaves.has(lf)) {
        // fall back: pick a single leaf from given
        const arr = Array.from(givenLeaves);
        const pick = arr[randInt(0, arr.length - 1)];
        askedLeaves.clear(); askedLeaves.add(pick);
        // map to a key for wording
        if (pick === "RR") askedKey = "bothRed";
        if (pick === "GG") askedKey = "bothGreen";
        if (pick === "RG") askedKey = "secondGreen"; // not perfect, but shouldn't happen often
        if (pick === "GR") askedKey = "secondRed";
        break;
      }
    }

    const leafNums = urnLeafNumerators(R, G, withReplacement);
    const numGiven = sumLeavesNums(leafNums, givenLeaves);
    const numAsked = sumLeavesNums(leafNums, askedLeaves);

    // P(asked | given) = (numAsked/den) / (numGiven/den) = numAsked/numGiven
    setAnswer(numAsked, numGiven);

    questionText.textContent =
      `An urn contains ${R} red balls and ${G} green balls. ` +
      `If a ball is drawn at random, ${returnText}, and a ball is drawn at random again, ` +
      `what is the probability that ${urnEventLabel(askedKey)}, given that ${urnEventLabel(givenKey)}?`;

    // Helpful TeX sums
    const leafToTex = (k) => {
      const n = leafNums[k];
      return fracTex(n, leafNums.den);
    };

    const texSum = (set) => Array.from(set).map(leafToTex).join(" + ") || "0";

    const askedSumTex = texSum(askedLeaves);
    const givenSumTex = texSum(givenLeaves);

    hintSteps = [
      `Use conditional probability: \\(P(A\\mid B)=\\frac{P(A\\cap B)}{P(B)}\\).`,
      `Here \\(B\\) is "${urnEventLabel(givenKey)}", and \\(A\\) is "${urnEventLabel(askedKey)}". Since \\(A\\subseteq B\\), we have \\(A\\cap B = A\\).`,
      `Compute \\(P(B)\\) by summing the relevant leaves: \\(P(B)= ${givenSumTex}\\).`,
      `Compute \\(P(A)\\) by summing the relevant leaves: \\(P(A)= ${askedSumTex}\\).`,
      `So \\(P(A\\mid B)=\\dfrac{${askedSumTex}}{${givenSumTex}} = \\dfrac{${numAsked}}{${numGiven}} = ${fracTex(numAsked, numGiven)}\\).`
    ];

    // Final hint: tree diagram (denominator in blue, numerator in green)
    const blue = new Set(givenLeaves);
    const green = new Set(askedLeaves);
    hintSteps.push(treeHintHtml(
      withReplacement ? 'Tree diagram (with replacement)' : 'Tree diagram (without replacement)',
      buildUrnTreeSVGVertical(R, G, withReplacement, green, blue)
    ));
  }

  // -----------------------------
  // Type (4): Conditional partition + property (Bayes-style)
  // -----------------------------
  const popBank = [
    { labelSing: 'fruit', labelPlur: 'fruits', items: ['Apples', 'Bananas', 'Oranges', 'Pears'] },
    { labelSing: 'animal', labelPlur: 'animals', items: ['Cats', 'Dogs', 'Birds', 'Bears'] },
    { labelSing: 'musical instrument', labelPlur: 'musical instruments', items: ['Trumpets', 'Flutes', 'Clarinets', 'Tubas'] },
    { labelSing: 'piece of furniture', labelPlur: 'pieces of furniture', items: ['Chairs', 'Tables', 'Couches', 'Beds'] },
    { labelSing: 'utensil', labelPlur: 'utensils', items: ['Forks', 'Spoons', 'Spatulas', 'Whisks'] },
    { labelSing: 'vehicle', labelPlur: 'vehicles', items: ['Sedans', 'Jeeps', 'SUVs', 'Trucks'] },
    { labelSing: 'shape', labelPlur: 'shapes', items: ['Squares', 'Triangles', 'Circles', 'Pentagons'] }
  ];

  const propertyByCategory = {
    'fruit': 'rotten',
    'animal': 'rabid',
    'musical instrument': 'brass',
    'piece of furniture': 'antique',
    'utensil': 'silver',
    'vehicle': 'electric',
    'shape': 'blue'
  };

  function randomPartition(total, k) {
    let cuts = [];
    for (let i = 0; i < k - 1; i++) cuts.push(randInt(1, total - 1));
    cuts.sort((a, b) => a - b);
    const parts = [];
    let prev = 0;
    for (let i = 0; i < cuts.length; i++) { parts.push(cuts[i] - prev); prev = cuts[i]; }
    parts.push(total - prev);
    return parts;
  }

  function type4LeafKey(i, which) {
    return which === "prop" ? `S${i}_P` : `S${i}_N`;
  }

  function leavesForSubset(i) {
    return new Set([type4LeafKey(i, "prop"), type4LeafKey(i, "not")]); // note: we'll normalize "not" below
  }

  function normalizeType4Key(k) {
    // allow "S0_not" as alias
    return k.replace("_not", "_N").replace("_prop", "_P");
  }

  function generateType4Conditional() {
    const pop = popBank[randInt(0, popBank.length - 1)];
    const prop = propertyByCategory[pop.labelSing];

    const N = randInt(10, 100);
    const k = randInt(2, 4);

    const items = shuffle([...pop.items]).slice(0, k);
    const counts = randomPartition(N, k);

    const propCounts = [];
    for (let i = 0; i < k; i++) {
      const p = randInt(1, 99);
      let c = Math.round(counts[i] * p / 100);
      c = Math.max(0, Math.min(counts[i], c));
      propCounts.push(c);
    }

    const breakdown = items.map((it, i) => `${counts[i]} ${it}`).join(', ');
    const propertyLines = items.map((it, i) => `${propCounts[i]} of the ${it.toLowerCase()} are ${prop}.`).join(' ');

    // Build leaf counts (since each leaf is a count out of N)
    const leafCounts = {};
    for (let i = 0; i < k; i++) {
      leafCounts[type4LeafKey(i, "prop")] = propCounts[i];
      leafCounts[type4LeafKey(i, "not")] = counts[i] - propCounts[i];
    }

    // Choose a GIVEN event (subset of leaves of size > 1)
    // We keep it simple and always word it without notation:
    //   - "is <prop>"  (k leaves)
    //   - "is not <prop>" (k leaves)
    //   - "is a <subset>" (2 leaves)
    //   - "is a <subset1> or a <subset2> (or a <subset3>)" (4-6 leaves)
    const givenType = randInt(1, 4);
    let givenLeaves = new Set();
    let givenPhrase = "";

    if (givenType === 1) {
      // is prop
      for (let i = 0; i < k; i++) givenLeaves.add(type4LeafKey(i, "prop"));
      givenPhrase = `it is ${prop}`;
    } else if (givenType === 2) {
      // is not prop
      for (let i = 0; i < k; i++) givenLeaves.add(type4LeafKey(i, "not"));
      givenPhrase = `it is not ${prop}`;
    } else if (givenType === 3) {
      const j = randInt(0, k - 1);
      givenLeaves.add(type4LeafKey(j, "prop"));
      givenLeaves.add(type4LeafKey(j, "not"));
      const subsetSing = singularize(items[j]).toLowerCase();
      givenPhrase = `it is ${articleFor(subsetSing)} ${subsetSing}`;
    } else {
      const howMany = randInt(2, Math.min(3, k));
      const idxs = shuffle([...Array(k).keys()]).slice(0, howMany);
      for (const j of idxs) {
        givenLeaves.add(type4LeafKey(j, "prop"));
        givenLeaves.add(type4LeafKey(j, "not"));
      }
      const subs = idxs.map(j => {
        const s = singularize(items[j]).toLowerCase();
        return `${articleFor(s)} ${s}`;
      });
      givenPhrase = `it is ${subs.length === 2 ? (subs[0] + " or " + subs[1]) : (subs.slice(0,-1).join(", ") + ", or " + subs[subs.length-1])}`;
    }

    // Choose an ASKED event that is a proper subset of the given event
    // We'll choose either:
    //   - a single leaf inside given: "is (not) prop and is a subset"
    // or (if given is a union of subsets) sometimes:
    //   - a whole subset (2 leaves) inside given: "is a subset"
    let askedLeaves = new Set();
    let askedPhrase = "";

    const givenArr = Array.from(givenLeaves);

    // Decide asked style
    const canAskWholeSubset = (givenType === 4); // union-of-subsets gives room for "is a subset" questions
    const askWholeSubset = canAskWholeSubset && randInt(0, 1) === 0;

    if (askWholeSubset) {
      // pick one of the subsets included in the given event
      // Find which subset indices appear in givenLeaves
      const included = [];
      for (let i = 0; i < k; i++) {
        const kp = type4LeafKey(i, "prop");
        const kn = type4LeafKey(i, "not");
        if (givenLeaves.has(kp) && givenLeaves.has(kn)) included.push(i);
      }
      const j = included[randInt(0, included.length - 1)];
      askedLeaves.add(type4LeafKey(j, "prop"));
      askedLeaves.add(type4LeafKey(j, "not"));

      const subsetSing = singularize(items[j]).toLowerCase();
      askedPhrase = `it is ${articleFor(subsetSing)} ${subsetSing}`;
    } else {
      // single leaf
      const picked = givenArr[randInt(0, givenArr.length - 1)];
      askedLeaves.add(picked);

      const m = picked.match(/^S(\d+)_(P|N)$/);
      const idx = parseInt(m[1], 10);
      const which = m[2];

      const subsetSing = singularize(items[idx]).toLowerCase();
      if (which === "P") askedPhrase = `it is ${prop} and is ${articleFor(subsetSing)} ${subsetSing}`;
      else askedPhrase = `it is not ${prop} and is ${articleFor(subsetSing)} ${subsetSing}`;
    }

    // Compute sums (counts out of N)
    const sumCounts = (set) => {
      let s = 0;
      for (const key of set) s += leafCounts[key];
      return s;
    };
    const denomCount = sumCounts(givenLeaves);
    const numerCount = sumCounts(askedLeaves);

    // Conditional probability = numerCount/denomCount
    setAnswer(numerCount, denomCount);

    questionText.textContent =
      `There are ${N} ${pop.labelPlur}, consisting of ${breakdown}. ` +
      `${propertyLines} ` +
      `If a ${pop.labelSing} is selected at random, what is the probability that ${askedPhrase}, given that ${givenPhrase}?`;

    // TeX sums (as probabilities)
    const texSumLeaves = (set) => {
      const terms = Array.from(set).map(k => fracTex(leafCounts[k], N));
      return terms.join(" + ") || "0";
    };
    const denomTex = texSumLeaves(givenLeaves);
    const numerTex = texSumLeaves(askedLeaves);

    hintSteps = [
      `Use conditional probability: \\(P(A\\mid B)=\\frac{P(A\\cap B)}{P(B)}\\).`,
      `Here \\(B\\) is "${givenPhrase}", and \\(A\\) is "${askedPhrase}". Since \\(A\\subseteq B\\), we have \\(A\\cap B = A\\).`,
      `Compute \\(P(B)\\) by summing the relevant leaves: \\(P(B)= ${denomTex}\\).`,
      `Compute \\(P(A)\\) by summing the relevant leaves: \\(P(A)= ${numerTex}\\).`,
      `So \\(P(A\\mid B)=\\dfrac{${numerTex}}{${denomTex}} = \\dfrac{${numerCount}}{${denomCount}} = ${fracTex(numerCount, denomCount)}\\).`
    ];

    // Final hint: tree diagram (blue = given, green = asked)
    const blue = new Set(Array.from(givenLeaves));
    const green = new Set(Array.from(askedLeaves));
    const subsetNames = items.map(x => x.toLowerCase());

    hintSteps.push(treeHintHtml(
      'Tree diagram',
      buildPartitionPropTreeSVGVertical(subsetNames, counts, prop, propCounts, green, blue)
    ));
  }

  // -----------------------------
  // Start button (Types 2 and 4 only)
  // -----------------------------
  startBtn.addEventListener('click', () => {
    playSound('click-sound');
    resetUIForNewQuestion();

    const qType = randInt(1, 2); // 1 -> urn, 2 -> partition/property
    if (qType === 1) generateType2Conditional();
    else generateType4Conditional();

    typeset([questionText]);
  });

  // -----------------------------
  // Hint button
  // -----------------------------
  hintBtn.addEventListener('click', () => {
    playSound('click-sound');

    if (!hintSteps || hintSteps.length === 0) {
      const hintPara = document.createElement('div');
      hintPara.classList.add('hint-step');
      hintPara.style.textAlign = 'center';
      hintPara.textContent = 'No hints are available for this question.';
      hintArea.appendChild(hintPara);
      typeset([hintPara]);
      return;
    }

    if (hintIndex < hintSteps.length) {
      const hintPara = document.createElement('div');
      hintPara.classList.add('hint-step');
      hintPara.style.textAlign = 'center';
      hintPara.innerHTML = hintSteps[hintIndex];
      hintArea.appendChild(hintPara);
      typeset([hintPara]);
      hintIndex++;
    }
  });

  // -----------------------------
  // Check answer
  // -----------------------------
  checkBtn.addEventListener('click', () => {
    playSound('click-sound');

    const raw = answerInput.value.trim();
    if (!raw) {
      feedback.textContent = 'Please enter an answer.';
      feedback.style.color = 'black';
      return;
    }

    const parsed = parseUserAnswer(raw);
    if (parsed.error) {
      feedback.textContent = parsed.error;
      feedback.style.color = 'black';
      return;
    }

    if (isCorrect(parsed)) {
      feedback.textContent = 'Correct!';
      feedback.style.color = 'green';
    } else {
      const exact = `${currentAnsNum}/${currentAnsDen}`;
      const dec = (currentAnsNum / currentAnsDen).toFixed(6).replace(/0+$/, '').replace(/\.$/, '');
      feedback.textContent = `Not quite. Correct answer is ${exact} (≈ ${dec}).`;
      feedback.style.color = 'crimson';
    }
  });
</script>



  <audio id="click-sound" src="button.mp3" preload="auto"></audio>
  <audio id="set-sound" src="set2.mp3" preload="auto"></audio>

</body>
</html>
