
<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Personal website of Ben Fraser, with math education activities for students and teachers.">
  <meta charset="UTF-8" />
  <title>Systems of Equations Activity</title>
  <link rel="stylesheet" href="/style.css" />

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>Systems of Equations Activity</h1>
    <div id="nav-placeholder"></div>
      <script>
fetch("/nav.html")
  .then(response => response.text())
  .then(html => {
    document.getElementById("nav-placeholder").innerHTML = html;

    const currentPath = window.location.pathname.replace(/\/index\.html$/, "/");
    const navLinks = document.querySelectorAll("#nav-placeholder a");
    navLinks.forEach(link => {
      const linkPath = new URL(link.href).pathname.replace(/\/index\.html$/, "/");
      if (linkPath === currentPath) {
        link.classList.add("active");
      }
    });

    const s = document.createElement("script");
    s.src = "/mascot.js";
    s.defer = true;
    document.body.appendChild(s); 
  })
  .catch(err => {
    console.error("Failed to load nav:", err);
  });
</script>
  </header>
  <main>

    <p>We have previously seen how to solve simple systems of equations: namely, when two lines were put in slope-intercept form, 
      setting their right-hand sides equal to one another to solve for \(x\) (and subsequently, \(y\).  This is a specific case 
      of a more general strategy for solving systems of equations: that is, multiple equations are all true, and we need to find 
      what values of the variables satisfy all simultaneously.
    </p>
    
    <p>Note that our previous strategy <b>reduced</b> the problem to solving an equation which contained only a single variable, 
      \(x\).  This will be our strategy in general: to eliminate variables from the problem, and solve over a reduced number of 
      variables.  This is called <b>Gaussian elimination</b>.  Operations we are allowed to perform are:
    </p>

    <ul>
      <li>Multiply an equation by a nonzero constant</li>
      <li>Add/subtract a multiple of one equation to/from another</li>
    </ul>
      
    <p>Generally, this algorithm will amount to multiplying two equations by different numbers so that the coefficients on one 
      of the variables line up across both equations, and then subtracting one equation from the other.  As far as <i>what</i> 
      numbers we multiply the equations by, the choice will look very much like giving two fractions common denominators: multiply 
      each equation by the coefficient of the variable on the other equation.  For instance, to solve the system
      \[2x + 5y = 9\]
      \[3x + 4y = 10\]
      we can multiply the first equation by 3, and the second equation by 2 (the coefficient of \(x\) in the other equation), 
      obtaining
      \[6x + 15y = 27\]
      \[6x + 8y = 7\]
      and then subtracting the second equation from the first, we get
      \[7y = y \implies y = 1\]
      and substituting this value for \(y\) into either of our starting equations, we solve for \(x\):
      \[2x + 5(1) = 9 \implies 2x = 4 \implies x = 2\]
    </p>


    <p>Another strategy we can use to solve systems of equations is <b>substitution</b>: wherein we can substitute one expression 
      for another when they are known to be equal to one another.  Some problems lend themselves particularly naturally to the 
      substitution strategy.  Take for instance the following word problem.
    </p>

    <p>A steak costs twice as much as a bowl of pasta, and a side of fries costs one third of what a bowl of pasta costs. 
      If you order all three items, it costs $70.  How much does each item cost?
    </p>

    <p>We start with some "let" statements, where we choose sensibly-named variables to represent the cost of each item:
    </p>

    <ul>
      <li>Let \(s\) be the price of a steak</li>
      <li>Let \(p\) be the price of a bowl of pasta</li>
      <li>Let \(f\) be the price of a side of fries</li>
    </ul>

    <p>Then, we can use the relationships between the prices of the items to obtain some equations:
    </p>

    <ul>
      <li>\(s = 2p\)</li>
      <li>\(f = \frac{1}{3}p\)</li>
      <li>s + p + f = 70</li>
    </ul>

    

    <div class="button-container">
      <button id="start-btn" class="rubber-button">Start!</button>
    </div>
    
    <p id="question-text" class="math"></p>

    <div class="button-container">
      <button id="hint-btn" class="rubber-button">Hint</button>
    </div>
    
    <div id="hint-area" class="math" style="margin-top: 1em; text-align: center"></div>


    <div id="answer-section" style="margin-top: 20px; text-align: center;">
      <label for="user-answer">Enter your answer:</label>
      <input type="text" id="user-answer" />
      <button id="check-answer-btn" class="rubber-button" style="margin-left: 0.5em;">Check Answer</button>
      <p id="answer-feedback" style="font-weight: bold; margin-top: 10px;"></p>
    </div>

  </main>
  <script>
  const hintBtn = document.getElementById('hint-btn');
  const hintArea = document.getElementById('hint-area');
  let hintSteps = [];
  let hintIndex = 0;

  const startBtn = document.getElementById('start-btn');
  const questionText = document.getElementById('question-text');

  const answerInput = document.getElementById('user-answer');
  const feedback = document.getElementById('answer-feedback');

  // Correct answer stored as reduced fraction num/den
  let currentAnsNum = null;
  let currentAnsDen = null;

  // -----------------------------
  // Helpers
  // -----------------------------
  function playSound(id) {
    const s = document.getElementById(id);
    if (s) {
      s.currentTime = 0;
      s.play();
    }
  }

  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }

  function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b !== 0) {
      const t = a % b;
      a = b;
      b = t;
    }
    return a === 0 ? 1 : a;
  }

  function reduceFrac(num, den) {
    if (den < 0) { den = -den; num = -num; }
    const g = gcd(num, den);
    return [num / g, den / g];
  }

  function setAnswer(num, den) {
    const r = reduceFrac(num, den);
    currentAnsNum = r[0];
    currentAnsDen = r[1];
  }

  function resetUIForNewQuestion() {
    feedback.textContent = '';
    feedback.style.color = 'black';
    answerInput.value = '';
    hintArea.innerHTML = '';
    hintSteps = [];
    hintIndex = 0;
  }


  function typeset(elements = []) {
    if (!window.MathJax) return;
    if (MathJax.typesetPromise) {
      if (elements.length > 0) MathJax.typesetPromise(elements);
      else MathJax.typesetPromise();
      return;
    }
    if (MathJax.typeset) {
      if (elements.length > 0) MathJax.typeset(elements);
      else MathJax.typeset();
    }
  }

  function toDecimalString(num, den) {
    const x = num / den;
    let s = x.toFixed(2);
    s = s.replace(/0+$/, '').replace(/\.$/, '');
    return s;
  }

  function joinWithOr(items) {
    if (items.length === 1) return items[0];
    if (items.length === 2) return `${items[0]} or ${items[1]}`;
    return `${items.slice(0, -1).join(', ')}, or ${items[items.length - 1]}`;
  }

  function singularize(word) {
    // Good enough for your current banks (apples->apple, SUVs->SUV, etc.)
    if (word.endsWith('s')) return word.slice(0, -1);
    return word;
  }

  function articleFor(word) {
    const first = word[0];
    const vowelLetter = /^[aeiou]/i.test(first);
    const anInitialism = /^[FHLMNRSX]/.test(first); // “an” F, H, L, M, N, R, S, X
    return (vowelLetter || anInitialism) ? 'an' : 'a';
  }


  function fracTex(num, den) {
    const r = reduceFrac(num, den);
    const n = r[0], d = r[1];
    if (d === 1) return `\\frac{${n}}{${d}}`;
    return `\\frac{${n}}{${d}}`;
  }

  function parseUserAnswer(raw) {
    // Accept:
    //  - integer: "3"
    //  - fraction: "3/8"
    //  - decimal: "0.375"
    //
    // Returns:
    //  { kind:'exact', num, den } for integer/fraction
    //  { kind:'decimal', value, relTol } for decimals (graded by relative tolerance)
    const s = raw.replace(/\s+/g, '');

    // Fraction a/b
    const fracMatch = s.match(/^([+-]?\d+)\/([+-]?\d+)$/);
    if (fracMatch) {
      const a = parseInt(fracMatch[1], 10);
      const b = parseInt(fracMatch[2], 10);
      if (b === 0) return { error: 'Denominator cannot be 0.' };
      const [rn, rd] = reduceFrac(a, b);
      return { kind: 'exact', num: rn, den: rd };
    }

    // Integer
    const intMatch = s.match(/^[+-]?\d+$/);
    if (intMatch) {
      const a = parseInt(s, 10);
      return { kind: 'exact', num: a, den: 1 };
    }

    // Decimal
    const decMatch = s.match(/^[+-]?\d*\.\d+$/);
    if (decMatch) {
      const value = Number(s);
      if (!Number.isFinite(value)) return { error: 'That decimal does not look valid.' };
      if (value < 0) return { error: 'Probabilities cannot be negative.' };
      // Allow decimals; grade with 0.01% relative tolerance
      return { kind: 'decimal', value, relTol: 0.0001 };
    }

    return { error: 'I couldn’t parse that. Use a fraction like 3/8 or a decimal like 0.375.' };
  }

  function isCorrect(parsed) {
    if (currentAnsNum === null || currentAnsDen === null) return false;
    const correctVal = currentAnsNum / currentAnsDen;

    if (!parsed || parsed.error) return false;

    if (parsed.kind === 'exact') {
      const [uNum, uDen] = reduceFrac(parsed.num, parsed.den);
      return (uNum === currentAnsNum && uDen === currentAnsDen);
    }

    if (parsed.kind === 'decimal') {
      const denom = Math.max(1e-12, Math.abs(correctVal));
      return Math.abs(parsed.value - correctVal) <= parsed.relTol * denom;
    }

    return false;
  }

  // -----------------------------
  // Banks
  // -----------------------------
  const type1Bank = [
    { categorySing: 'fruit', categoryPlur: 'fruits', items: ['apples', 'bananas', 'oranges', 'pears', 'grapefruits'] },
    { categorySing: 'animal', categoryPlur: 'animals', items: ['cats', 'dogs', 'birds', 'bears', 'lions'] },
    { categorySing: 'musical instrument', categoryPlur: 'musical instruments', items: ['trumpets', 'flutes', 'clarinets', 'tubas', 'saxophones'] },
    { categorySing: 'piece of furniture', categoryPlur: 'pieces of furniture', items: ['chairs', 'tables', 'couches', 'beds', 'dressers'] },
    { categorySing: 'utensil', categoryPlur: 'utensils', items: ['forks', 'spoons', 'knives', 'spatulas', 'whisks'] },
    { categorySing: 'vehicle', categoryPlur: 'vehicles', items: ['sedans', 'jeeps', 'SUVs', 'trucks', 'vans'] },
    { categorySing: 'shape', categoryPlur: 'shapes', items: ['squares', 'triangles', 'circles', 'pentagons', 'hexagons'] }
  ];

  const type3Bank = [
    { e: 'it rains', f: 'the temperature is below 5°C' },
    { e: 'you score a touchdown', f: 'you are the game MVP' },
    { e: 'the Best Actor winner is from Europe', f: 'the Best Actor winner is over 40 years old' },
    { e: 'a newborn has brown hair', f: 'a newborn weighs more than 8 lbs at birth' },
    { e: 'a randomly selected email is spam', f: 'the email contains the word “free”' },
    { e: 'a randomly selected day is a weekend', f: 'it rains that day' },
    { e: 'a student passes the final exam', f: 'the student studied at least 5 hours' },
    { e: 'a customer buys something', f: 'the customer used a coupon' }
  ];

  const type4Bank = [
    {
      population: 'employees at Ben Co',
      member: 'employee',
      aLabel: 'lawyers at Ben Co',
      bLabel: 'employees at Ben Co earning more than 100K'
    },
    {
      population: 'students at VIU',
      member: 'student',
      aLabel: 'students enrolled in Math 132',
      bLabel: 'students enrolled in Math 161'
    },
    {
      population: 'players in the NHL',
      member: 'player',
      aLabel: 'centers in the NHL',
      bLabel: 'players in the NHL who have averaged more than a point per game'
    },
    {
      population: 'books in a library',
      member: 'book',
      aLabel: 'fiction books',
      bLabel: 'books currently checked out'
    },
    {
      population: 'cars in a parking lot',
      member: 'car',
      aLabel: 'cars that are SUVs',
      bLabel: 'cars that are electric'
    }
  ];

  // -----------------------------
  // Type 1
  // -----------------------------
  function generateType1() {
    const scenario = type1Bank[randInt(0, type1Bank.length - 1)];

    const N = randInt(20, 80);
    const k = randInt(2, 5);

    // choose k distinct items from the 5
    const indices = [0, 1, 2, 3, 4];
    for (let i = indices.length - 1; i > 0; i--) {
      const j = randInt(0, i);
      [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    const chosenTypesIdx = indices.slice(0, k);
    const chosenTypes = chosenTypesIdx.map(i => scenario.items[i]);

    // random positive parts summing to N
    let cuts = [];
    for (let i = 0; i < k - 1; i++) cuts.push(randInt(1, N - 1));
    cuts.sort((a, b) => a - b);

    const counts = [];
    let prev = 0;
    for (let i = 0; i < cuts.length; i++) {
      counts.push(cuts[i] - prev);
      prev = cuts[i];
    }
    counts.push(N - prev);

    // choose between 1 and k-1 of the pieces for the OR question
    const m = randInt(1, k - 1);
    const idx2 = [...Array(k).keys()];
    for (let i = idx2.length - 1; i > 0; i--) {
      const j = randInt(0, i);
      [idx2[i], idx2[j]] = [idx2[j], idx2[i]];
    }
    const picked = idx2.slice(0, m).sort((a, b) => a - b);

    const favorable = picked.reduce((acc, i) => acc + counts[i], 0);
    setAnswer(favorable, N);

    const breakdown = chosenTypes
      .map((t, i) => `${counts[i]} ${t}`)
      .join(', ');

    const askedTypes = picked.map(i => chosenTypes[i]);
    const askedSingles = askedTypes.map(t => {
      const s = singularize(t);
      return `${articleFor(s)} ${s}`;
    });
    const askedPhrase = joinWithOr(askedSingles);

    questionText.textContent =
      `A ${scenario.categorySing} is randomly selected from a set of ${N} ${scenario.categoryPlur}. ` +
      `There are ${breakdown}. ` +
      `What is the probability that ${askedPhrase} is selected?`;

    hintSteps = [
  `Add the counts for the types listed in the question to get the number of favorable outcomes.`,
  `There are ${picked.map(i => counts[i]).join(' + ')} = ${favorable} ${scenario.categoryPlur} which are ${askedTypes.join(' or ')}.`,
  `Divide by the total number of outcomes (the total size of the set).`,
  `The proportion of ${scenario.categoryPlur} which are ${askedTypes.join(' or ')} is \\(${fracTex(favorable, N)}\\).`
];
  }

  // -----------------------------
  // Type 2
  // -----------------------------
  function generateType2() {
    const n = randInt(10, 100);
    const r = randInt(1, 3);

    const points = new Set();
    while (points.size < 2 * r) points.add(randInt(1, n));
    const sorted = Array.from(points).sort((a, b) => a - b);

    const intervals = [];
    for (let i = 0; i < sorted.length; i += 2) {
      let a = sorted[i], b = sorted[i + 1];
      if (b < a) [a, b] = [b, a];
      intervals.push([a, b]);
    }
    intervals.sort((I, J) => I[0] - J[0]);

    const disjoint = [];
    for (const [s, t] of intervals) {
      if (disjoint.length === 0) disjoint.push([s, t]);
      else {
        const last = disjoint[disjoint.length - 1];
        if (s > last[1]) disjoint.push([s, t]);
        else {
          const ns = last[1] + 1;
          if (ns <= t) disjoint.push([ns, t]);
        }
      }
    }

    while (disjoint.length < r) {
      const x = randInt(1, n);
      let ok = true;
      for (const [s, t] of disjoint) if (x >= s && x <= t) ok = false;
      if (ok) disjoint.push([x, x]);
      if (disjoint.length > 10) break;
    }

    disjoint.sort((I, J) => I[0] - J[0]);
    const finalIntervals = disjoint.slice(0, r);

    let outerUsed = 0;
    const phrases = finalIntervals.map(([s, t]) => {
      if (s === 1 && outerUsed < 2) {
        outerUsed++;
        return `less than ${t + 1}`;
      }
      if (t === n && outerUsed < 2) {
        outerUsed++;
        return `${s} or higher`;
      }
      if (s === t) return `exactly ${s}`;
      return `between ${s} and ${t} (inclusive)`;
    });

    const favorable = finalIntervals.reduce((acc, [s, t]) => acc + (t - s + 1), 0);
    setAnswer(favorable, n);

    questionText.textContent =
      `A ${n}-sided die is rolled. ` +
      `What is the probability that the number rolled is ${joinWithOr(phrases)}?`;

    hintSteps = [
  `Count how many outcomes satisfy at least one of the listed conditions.`,
  `There are ${favorable} natural numbers which are ${joinWithOr(phrases)}.`,
  `Divide by the total number of outcomes (${n}).`,
  `The proportion of natural numbers which are ${n} or less that are ${joinWithOr(phrases)} is \\(${fracTex(favorable, n)}\\).`
];
  }

  // -----------------------------
  // Type 3
  // -----------------------------
  function generateType3() {
    const scenario = type3Bank[randInt(0, type3Bank.length - 1)];

    const den = 100;
    const pE = randInt(10, 80);
    const pF = randInt(10, 80);

    const minInt = Math.max(0, pE + pF - den);
    const maxInt = Math.min(pE, pF);
    const pInt = randInt(minInt, maxInt);

    const pUnion = pE + pF - pInt;
    const giveUnion = Math.random() < 0.5;

    if (giveUnion) {
      setAnswer(pInt, den);
      questionText.textContent =
        `There is a ${toDecimalString(pE, den)} probability that ${scenario.e}, ` +
        `a ${toDecimalString(pF, den)} probability that ${scenario.f}, ` +
        `and a ${toDecimalString(pUnion, den)} probability that ${scenario.e} or ${scenario.f}. ` +
        `What is the probability that ${scenario.e} and ${scenario.f}?`;
    } else {
      setAnswer(pUnion, den);
      questionText.textContent =
        `There is a ${toDecimalString(pE, den)} probability that ${scenario.e}, ` +
        `a ${toDecimalString(pF, den)} probability that ${scenario.f}, ` +
        `and a ${toDecimalString(pInt, den)} probability that ${scenario.e} and ${scenario.f}. ` +
        `What is the probability that ${scenario.e} or ${scenario.f}?`;
    }

    hintSteps = (() => {
  const eText = scenario.e;
  const fText = scenario.f;

  if (giveUnion) {
    return [
      `Use inclusion-exclusion.`,
      `Rearrange depending on which quantity you’re missing.`,
      `\\(P(E \\cap F) = P(E) + P(F) - P(E \\cup F)\\)`,
      `Let \\(E\\) be the event that ${eText}, and let \\(F\\) be the event that ${fText}.`,
      `Substitute: \\(P(E \\cap F) = ${fracTex(pE, den)} + ${fracTex(pF, den)} - ${fracTex(pUnion, den)} = ${fracTex(pInt, den)}\\).`
    ];
  } else {
    return [
      `Use inclusion-exclusion.`,
      `Rearrange depending on which quantity you’re missing.`,
      `\\(P(E \\cup F) = P(E) + P(F) - P(E \\cap F)\\)`,
      `Let \\(E\\) be the event that ${eText}, and let \\(F\\) be the event that ${fText}.`,
      `Substitute: \\(P(E \\cup F) = ${fracTex(pE, den)} + ${fracTex(pF, den)} - ${fracTex(pInt, den)} = ${fracTex(pUnion, den)}\\).`
    ];
  }
})();
  }

  // -----------------------------
  // Type 4
  // -----------------------------
  function generateType4() {
    const scenario = type4Bank[randInt(0, type4Bank.length - 1)];

    const N = randInt(80, 600);
    const a = randInt(10, Math.floor(0.75 * N));
    const b = randInt(10, Math.floor(0.75 * N));

    const giveUnion = Math.random() < 0.5;

    let u;
    let inter;

    if (giveUnion) {
      const uMin = Math.max(a, b);
      const uMax = Math.min(N, a + b);
      u = randInt(uMin, uMax);
      inter = a + b - u;

      setAnswer(inter, N);

      questionText.textContent =
        `There are ${N} ${scenario.population}. ` +
        `${a} are ${scenario.aLabel}, ${b} are ${scenario.bLabel}, ` +
        `and ${u} are ${scenario.aLabel} or ${scenario.bLabel}. ` +
        `If a ${scenario.member} is selected at random, what is the probability they are ` +
        `${scenario.aLabel} and ${scenario.bLabel}?`;
    } else {
      const iMin = Math.max(0, a + b - N);
      const iMax = Math.min(a, b);
      inter = randInt(iMin, iMax);
      u = a + b - inter;

      setAnswer(u, N);

      questionText.textContent =
        `There are ${N} ${scenario.population}. ` +
        `${a} are ${scenario.aLabel}, ${b} are ${scenario.bLabel}, ` +
        `and ${inter} are ${scenario.aLabel} and ${scenario.bLabel}. ` +
        `If a ${scenario.member} is selected at random, what is the probability they are ` +
        `${scenario.aLabel} or ${scenario.bLabel}?`;
    }

    hintSteps = (() => {
  const A = scenario.aLabel;
  const B = scenario.bLabel;

  if (giveUnion) {
    return [
      `Use inclusion-exclusion: \\(|A \\cup B| = |A| + |B| - |A \\cap B|\\).`,
      `Find the missing amount, \\(|A \\cap B|\\).`,
      `Let \\(A =\\) ${A} and let \\(B =\\) ${B}.`,
      `Substitute: \\(${u} = ${a} + ${b} - |A \\cap B|\\).`,
      `So \\(|A \\cap B| = ${a} + ${b} - ${u} = ${inter}\\).`,
      `Divide by the total population to get the probability.`,
      `The proportion of ${scenario.population} which are ${A} and ${B} is \\(${fracTex(inter, N)}\\).`
    ];
  } else {
    return [
      `Use inclusion-exclusion: \\(|A \\cup B| = |A| + |B| - |A \\cap B|\\).`,
      `Find the missing amount, \\(|A \\cup B|\\).`,
      `Let \\(A =\\) ${A} and let \\(B =\\) ${B}.`,
      `Substitute: \\(|A \\cup B| = ${a} + ${b} - ${inter}\\).`,
      `So \\(|A \\cup B| = ${u}\\).`,
      `Divide by the total population to get the probability.`,
      `The proportion of ${scenario.population} which are ${A} or ${B} is \\(${fracTex(u, N)}\\).`
    ];
  }
})();
  }

  // -----------------------------
  // Start: generate a question
  // -----------------------------
  startBtn.addEventListener('click', () => {
    playSound('click-sound');
    resetUIForNewQuestion();

    const qType = randInt(1, 4);

    if (qType === 1) generateType1();
    if (qType === 2) generateType2();
    if (qType === 3) generateType3();
    if (qType === 4) generateType4();
  });

  // -----------------------------
  // Check answer
  // -----------------------------
  document.getElementById('check-answer-btn').addEventListener('click', () => {
    playSound('click-sound');

    const raw = answerInput.value.trim();
    if (!raw) {
      feedback.textContent = 'Please enter an answer.';
      feedback.style.color = 'black';
      return;
    }

    const parsed = parseUserAnswer(raw);
    if (parsed.error) {
      feedback.textContent = parsed.error;
      feedback.style.color = 'black';
      return;
    }

    if (isCorrect(parsed)) {
      feedback.textContent = 'Correct!';
      feedback.style.color = 'green';
    } else {
      const exact = `${currentAnsNum}/${currentAnsDen}`;
      const dec = (currentAnsNum / currentAnsDen).toFixed(6).replace(/0+$/, '').replace(/\.$/, '');
      feedback.textContent = `Not quite. Correct answer is ${exact} (≈ ${dec}).`;
      feedback.style.color = 'crimson';
    }
  });

  // -----------------------------
  // Hint button (centered)
  // -----------------------------
  hintBtn.addEventListener('click', () => {
    playSound('click-sound');

    if (!hintSteps || hintSteps.length === 0) {
      const hintPara = document.createElement('div');
      hintPara.classList.add('hint-step');
      hintPara.style.textAlign = 'center';
      hintPara.textContent = 'No hints are available for this question.';
      hintArea.appendChild(hintPara);
      typeset([hintPara]);
      return;
    }

    if (hintIndex < hintSteps.length) {
      const hintPara = document.createElement('div');
      hintPara.classList.add('hint-step');
      hintPara.style.textAlign = 'center';
      hintPara.innerHTML = hintSteps[hintIndex];
      hintArea.appendChild(hintPara);
      typeset([hintPara]);
      hintIndex++;
    }
  });
</script>


  <audio id="click-sound" src="button.mp3" preload="auto"></audio>
  <audio id="set-sound" src="set2.mp3" preload="auto"></audio>

</body>
</html>
