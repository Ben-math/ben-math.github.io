
<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Personal website of Ben Fraser, with math education activities for students and teachers.">
  <meta charset="UTF-8" />
  <title>Binomial Distribution Activity</title>
  <link rel="stylesheet" href="/style.css" />

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>Binomial Distribution Activity</h1>
    <div id="nav-placeholder"></div>
      <script>
fetch("/nav.html")
  .then(response => response.text())
  .then(html => {
    document.getElementById("nav-placeholder").innerHTML = html;

    const currentPath = window.location.pathname.replace(/\/index\.html$/, "/");
    const navLinks = document.querySelectorAll("#nav-placeholder a");
    navLinks.forEach(link => {
      const linkPath = new URL(link.href).pathname.replace(/\/index\.html$/, "/");
      if (linkPath === currentPath) {
        link.classList.add("active");
      }
    });

    const s = document.createElement("script");
    s.src = "/mascot.js";
    s.defer = true;
    document.body.appendChild(s); 
  })
  .catch(err => {
    console.error("Failed to load nav:", err);
  });
</script>
  </header>
  <main>

    <p>A Bernoulli trial is an experiment which can either be considered a success or a failure.  For instance, one may consider flipping heads a 
      success (in which case flipping tails is a failure), or rolling a 2 or lower a success (in which case rolling a 3 or higher is a failure).
    </p>
    
    <p>If \(n\) many Bernoulli trials are performed, each with probability \(p\) of success, then the random variable \(X\) with parameters \(n,p\) is 
      called a <b>binomial random variable</b>.  Its pdf is called a <b>binomial distribution</b>, given by
      \[f(x;n,p) = \binom{n}{x}p^x(1-p)^{n-x} \hspace{2cm} \text{ for } x \in \{0, 1, ..., n\}\]
      The input x is the number of successes, so \(f(x; n, p)\) gives the probability of having \(x\) many successes when doing \(n\) many Bernoulli 
      trials that have a probability \(p\) of success.
    </p>

      
    <p>The Binomial coefficients \(\binom{n}{x}\) are entries in Pascal's triangle, can be computed via the formula
      \[\binom{n}{x} = \frac{n!}{(n-x)!x!}\]
      or by typing "nCx" (read as \(n\) choose \(x\)) into your calculator.
    </p>


    <p>For example, let us consider the Bernoulli trial where a success is  rolling a sum of 9 or higher on two 6-sided dice.  This has a probability of 
      \(\frac{10}{36} = \frac{5}{18}\).  If we perform this experiment 20 times, then the corresponding binomial random variable has parameters 
      \(\left(20, \frac{5}{18}\right)\), and pdf
      \[f\left(x;20,\frac{5}{18}\right) = \binom{20}{x}\left(\frac{5}{18}\right)^x\left(\frac{13}{18}\right)^{20-x}\]
      Since successes are less likely than failures, we see that the taller columns in the pdf's histogram tend leftwards:
    </p>

    <p>For instance, to find the probability of rolling a 9 or higher 6 out of the 20 times, we compute
      \[f\left(6;20,\frac{5}{18}\right) = \binom{20}{6}\left(\frac{5}{18}\right)^6\left(\frac{13}{18}\right)^{14} = 0.187\]
      Note that the probability above corresponds to the odds of 6 successes and 14 failures.
    </p>

    <p>We might also want to answer questions of the form
      \[\text{``What is the probability of rolling a 9 or higher 2 or fewer times?''}\]
      To answer this question, we are finding the following sum:
      \[P(X \leq 2) = P(X = 0) + P(X = 1) + P(X = 2) = f\left(0;20,\frac{5}{18}\right) + f\left(1;20,\frac{5}{18}\right) + 
      f\left(2;20,\frac{5}{18}\right) \approx 0.055\]
      That is, we are summing the 3 leftmost columns in the histogram:
    </p>

    <p>The preceding required us to compute the value of the pdf 3 times for our sum, which was quite time consuming.  Consider the problem 
      \[\text{``What is the probability of rolling a 9 or higher 18 or fewer times?''}\]
      We wouldn't want to find the sum
      \[P(X \leq 18) = P(X = 0) + P(X = 1) + ... + P(X = 18)\]
      However, observe that the complement of the event "rolling a 9 or higher 18 or fewer times" is "rolling a 9 or higher 19 or more times".  That is, 
      we can compute the easier sum
      \[P(X \leq 18) = 1 - P(X \geq 19) = 1 - (P(X = 19) + P(X = 20)) = 1 - (f\left(19;20,\frac{5}{18}\right) + f\left(20;20,\frac{5}{18}\right)) \approx 
      0.9999999996\]
      That is, we sum the two rightmost columns of the histogram, and subtract the result from 1:
    </p>


    <p>Finally, we have convenient formulas which simplify the computation of mean and variance specifically for binomial distributions: 
      \[\mu = np \hspace{2cm} \sigma^2 = np(1-p)\]
      In our running example, we find
      \[\mu = 20\left(\frac{5}{18}\right) \approx 5.56 \hspace{2cm} \sigma = \sqrt{20\left(\frac{5}{18}\right)\left(\frac{13}{18}\right)} \approx 2\]
    </p>

    <p>

      <div id="dice-histogram" style="margin: 1rem auto; max-width: 640px;"></div>

    </p>


    

    <div class="button-container">
      <button id="start-btn" class="rubber-button">Start!</button>
    </div>

    <p id="question-text" class="math"></p>

    <div id="activity-area" style="margin-top: 1rem;">
      <div id="table-area" class="math" style="margin: 1rem auto; max-width: 900px; text-align: center;"></div>

      <div id="mean-area" class="math" style="margin-top: 0.75rem; text-align: center;"></div>

      <div id="work-area" class="math" style="margin-top: 1rem; text-align: center;"></div>

      <div id="histogram-area" style="margin: 1rem auto; max-width: 740px;"></div>

      <p id="stage-feedback" style="font-weight: bold; margin-top: 0.75rem; text-align: center;"></p>

      <div class="button-container" style="gap: 0.75rem;">
        <button id="hint-btn" class="rubber-button">Hint</button>
        <button id="next-btn" class="rubber-button">Next</button>
      </div>
    </div>
</main>
  
<script>
  const startBtn = document.getElementById('start-btn');
  const hintBtn = document.getElementById('hint-btn');
  const nextBtn = document.getElementById('next-btn');

  const questionText = document.getElementById('question-text');
  const tableArea = document.getElementById('table-area');
  const meanArea = document.getElementById('mean-area');
  const workArea = document.getElementById('work-area');
  const histogramArea = document.getElementById('histogram-area');
  const stageFeedback = document.getElementById('stage-feedback');

  // -----------------------------
  // Helpers
  // -----------------------------
  function playSound(id) {
    const s = document.getElementById(id);
    if (s) { s.currentTime = 0; s.play(); }
  }

  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }

  function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b !== 0) { const t = a % b; a = b; b = t; }
    return a === 0 ? 1 : a;
  }

  function reduceFrac(num, den) {
    if (den < 0) { den = -den; num = -num; }
    const g = gcd(num, den);
    return [num / g, den / g];
  }

  function addFrac(aNum, aDen, bNum, bDen) {
    const num = aNum * bDen + bNum * aDen;
    const den = aDen * bDen;
    return reduceFrac(num, den);
  }

  function subFrac(aNum, aDen, bNum, bDen) {
    return addFrac(aNum, aDen, -bNum, bDen);
  }

  function mulFrac(aNum, aDen, bNum, bDen) {
    return reduceFrac(aNum * bNum, aDen * bDen);
  }

  function fracToTex(num, den) {
    const [n, d] = reduceFrac(num, den);
    if (d === 1) return `${n}`;
    return `\\frac{${n}}{${d}}`;
  }

  function fracToString(num, den) {
    const [n, d] = reduceFrac(num, den);
    if (d === 1) return `${n}`;
    return `${n}/${d}`;
  }

  function typeset(elements = []) {
    if (!window.MathJax) return;
    if (MathJax.typesetPromise) {
      if (elements.length > 0) MathJax.typesetPromise(elements);
      else MathJax.typesetPromise();
      return;
    }
    if (MathJax.typeset) {
      if (elements.length > 0) MathJax.typeset(elements);
      else MathJax.typeset();
    }
  }

  function parseNumber(raw) {
    // Accept integer, fraction, or decimal.
    const s = (raw ?? '').trim().replace(/\s+/g, '');
    if (!s) return { error: 'Please enter a value.' };

    const fracMatch = s.match(/^([+-]?\d+)\/([+-]?\d+)$/);
    if (fracMatch) {
      const a = parseInt(fracMatch[1], 10);
      const b = parseInt(fracMatch[2], 10);
      if (b === 0) return { error: 'Denominator cannot be 0.' };
      const [n, d] = reduceFrac(a, b);
      return { kind: 'frac', num: n, den: d, value: n / d };
    }

    const intMatch = s.match(/^[+-]?\d+$/);
    if (intMatch) {
      const a = parseInt(s, 10);
      return { kind: 'frac', num: a, den: 1, value: a };
    }

    const decMatch = s.match(/^[+-]?\d*\.\d+$/);
    if (decMatch) {
      const v = Number(s);
      if (!Number.isFinite(v)) return { error: 'That decimal does not look valid.' };
      return { kind: 'dec', value: v };
    }

    return { error: 'I couldnâ€™t parse that. Use an integer, a fraction like 3/8, or a decimal like 0.375.' };
  }

  function relClose(a, b, relTol) {
    const denom = Math.max(1e-12, Math.abs(b));
    return Math.abs(a - b) <= relTol * denom;
  }

  function inputMatchesRational(parsed, tNum, tDen, relTol = 0.001) {
    const target = tNum / tDen;
    if (parsed.error) return false;
    if (parsed.kind === 'frac') {
      const [n, d] = reduceFrac(parsed.num, parsed.den);
      const [tn, td] = reduceFrac(tNum, tDen);
      return (n === tn && d === td);
    }
    if (parsed.kind === 'dec') return relClose(parsed.value, target, relTol);
    return false;
  }

  // -----------------------------
  // Inline-SVG histogram for discrete pdfs (already used above)
  // -----------------------------
  // Usage:
  //   renderDiscreteHistogram('#some-div', [{x:2,p:1/36}, ...], { title: '...' })
  function renderDiscreteHistogram(container, points, options = {}) {
    const el = (typeof container === 'string') ? document.querySelector(container) : container;
    if (!el) return;

    const W = options.width ?? 620;
    const H = options.height ?? 240;
    const pad = { left: 44, right: 16, top: (options.title ? 30 : 14), bottom: 46, ...(options.padding ?? {}) };

    const data = (points || []).map(d => ({ x: d.x, p: d.p })).sort((a, b) => a.x - b.x);
    if (data.length === 0) {
      el.textContent = 'No data to plot.';
      return;
    }

    const maxP = Math.max(...data.map(d => d.p));
    const plotW = W - pad.left - pad.right;
    const plotH = H - pad.top - pad.bottom;

    const xStep = plotW / data.length;

    const y = (p) => pad.top + (1 - (p / maxP)) * plotH;
    const barW = xStep * 0.78;
    const x0 = (i) => pad.left + i * xStep + (xStep - barW) / 2;

    const svgNS = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', String(H));
    svg.setAttribute('role', 'img');
    svg.setAttribute('aria-label', options.ariaLabel ?? 'Histogram of a discrete probability distribution');

    const g = document.createElementNS(svgNS, 'g');
    svg.appendChild(g);

    if (options.title) {
      const t = document.createElementNS(svgNS, 'text');
      t.setAttribute('x', String(W / 2));
      t.setAttribute('y', '18');
      t.setAttribute('text-anchor', 'middle');
      t.setAttribute('font-size', '14');
      t.setAttribute('font-weight', '600');
      t.setAttribute('fill', 'currentColor');
      t.textContent = options.title;
      g.appendChild(t);
    }

    const axisColor = options.axisColor ?? 'currentColor';
    const axisOpacity = options.axisOpacity ?? '0.55';

    const xAxis = document.createElementNS(svgNS, 'line');
    xAxis.setAttribute('x1', String(pad.left));
    xAxis.setAttribute('y1', String(pad.top + plotH));
    xAxis.setAttribute('x2', String(pad.left + plotW));
    xAxis.setAttribute('y2', String(pad.top + plotH));
    xAxis.setAttribute('stroke', axisColor);
    xAxis.setAttribute('stroke-opacity', axisOpacity);
    xAxis.setAttribute('stroke-width', '1');
    g.appendChild(xAxis);

    const yAxis = document.createElementNS(svgNS, 'line');
    yAxis.setAttribute('x1', String(pad.left));
    yAxis.setAttribute('y1', String(pad.top));
    yAxis.setAttribute('x2', String(pad.left));
    yAxis.setAttribute('y2', String(pad.top + plotH));
    yAxis.setAttribute('stroke', axisColor);
    yAxis.setAttribute('stroke-opacity', axisOpacity);
    yAxis.setAttribute('stroke-width', '1');
    g.appendChild(yAxis);

    const ticks = options.yTicks ?? 3;
    for (let k = 0; k < ticks; k++) {
      const frac = (ticks === 1) ? 0 : k / (ticks - 1);
      const yy = pad.top + (1 - frac) * plotH;

      const tick = document.createElementNS(svgNS, 'line');
      tick.setAttribute('x1', String(pad.left - 4));
      tick.setAttribute('y1', String(yy));
      tick.setAttribute('x2', String(pad.left));
      tick.setAttribute('y2', String(yy));
      tick.setAttribute('stroke', axisColor);
      tick.setAttribute('stroke-opacity', axisOpacity);
      tick.setAttribute('stroke-width', '1');
      g.appendChild(tick);

      const lab = document.createElementNS(svgNS, 'text');
      lab.setAttribute('x', String(pad.left - 8));
      lab.setAttribute('y', String(yy + 4));
      lab.setAttribute('text-anchor', 'end');
      lab.setAttribute('font-size', '12');
      lab.setAttribute('fill', axisColor);
      lab.setAttribute('fill-opacity', axisOpacity);
      const val = frac * maxP;
      lab.textContent = (options.yFormatter ? options.yFormatter(val) : val.toFixed(3).replace(/0+$/, '').replace(/\.$/, ''));
      g.appendChild(lab);
    }

    for (let i = 0; i < data.length; i++) {
      const d = data[i];
      const x = x0(i);
      const yy = y(d.p);
      const h = (pad.top + plotH) - yy;

      const rect = document.createElementNS(svgNS, 'rect');
      rect.setAttribute('x', String(x));
      rect.setAttribute('y', String(yy));
      rect.setAttribute('width', String(barW));
      rect.setAttribute('height', String(Math.max(0, h)));
      rect.setAttribute('fill', options.barFill ?? 'currentColor');
      rect.setAttribute('fill-opacity', options.barFillOpacity ?? '0.35');
      rect.setAttribute('stroke', options.barStroke ?? 'currentColor');
      rect.setAttribute('stroke-opacity', options.barStrokeOpacity ?? '0.75');
      rect.setAttribute('stroke-width', options.barStrokeWidth ?? '1');
      g.appendChild(rect);

      const xl = document.createElementNS(svgNS, 'text');
      xl.setAttribute('x', String(x + barW / 2));
      xl.setAttribute('y', String(pad.top + plotH + 20));
      xl.setAttribute('text-anchor', 'middle');
      xl.setAttribute('font-size', '12');
      xl.setAttribute('fill', 'currentColor');
      xl.setAttribute('fill-opacity', '0.85');
      xl.textContent = String(d.x);
      g.appendChild(xl);
    }

    if (options.xLabel) {
      const xl2 = document.createElementNS(svgNS, 'text');
      xl2.setAttribute('x', String(pad.left + plotW / 2));
      xl2.setAttribute('y', String(H - 10));
      xl2.setAttribute('text-anchor', 'middle');
      xl2.setAttribute('font-size', '12');
      xl2.setAttribute('fill', 'currentColor');
      xl2.setAttribute('fill-opacity', '0.85');
      xl2.textContent = options.xLabel;
      g.appendChild(xl2);
    }

    if (options.yLabel) {
      const yl2 = document.createElementNS(svgNS, 'text');
      yl2.setAttribute('x', '14');
      yl2.setAttribute('y', String(pad.top + plotH / 2));
      yl2.setAttribute('text-anchor', 'middle');
      yl2.setAttribute('font-size', '12');
      yl2.setAttribute('fill', 'currentColor');
      yl2.setAttribute('fill-opacity', '0.85');
      yl2.setAttribute('transform', `rotate(-90 14 ${pad.top + plotH / 2})`);
      yl2.textContent = options.yLabel;
      g.appendChild(yl2);
    }

    el.innerHTML = '';
    el.appendChild(svg);
  }

  // -----------------------------
  // Static histogram for the two-dice example in the text above
  // -----------------------------
  renderDiscreteHistogram('#dice-histogram', [
    { x: 2,  p: 1/36 },
    { x: 3,  p: 2/36 },
    { x: 4,  p: 3/36 },
    { x: 5,  p: 4/36 },
    { x: 6,  p: 5/36 },
    { x: 7,  p: 6/36 },
    { x: 8,  p: 5/36 },
    { x: 9,  p: 4/36 },
    { x: 10, p: 3/36 },
    { x: 11, p: 2/36 },
    { x: 12, p: 1/36 }
  ], {
    title: 'Histogram of the pdf for the sum of two dice',
    xLabel: 'x',
    yLabel: 'f(x)',
    yFormatter: (v) => {
      const n = Math.round(v * 36);
      const den = 36;
      const g = gcd(n, den);
      const nn = n / g;
      const dd = den / g;
      return (n === 0) ? '0' : `${nn}/${dd}`;
    }
  });

  // -----------------------------
  // Activity: Binomial Distribution (Type 1 for now)
  // -----------------------------
  const REL_TOL = 0.001; // 0.1% relative tolerance for decimal answers

  let stage = 0; // 0 = not started, 1..4
  let problem = null;

  function clearActivity() {
    tableArea.innerHTML = '';
    meanArea.innerHTML = '';
    workArea.innerHTML = '';
    histogramArea.innerHTML = '';
    setFeedback('');
    typeset();
  }

  function setFeedback(msg, color = 'black') {
    stageFeedback.textContent = msg;
    stageFeedback.style.color = color;
  }

  // robust nCk (n up to 50)
  function combInt(n, k) {
    if (k < 0 || k > n) return 0;
    k = Math.min(k, n - k);
    let num = 1;
    let den = 1;
    for (let i = 1; i <= k; i++) {
      num *= (n - (k - i));
      den *= i;
      const g = gcd(num, den);
      num /= g; den /= g;
    }
    return num / den;
  }

  function binomPMF(n, p, x) {
    return combInt(n, x) * Math.pow(p, x) * Math.pow(1 - p, n - x);
  }

  function parseDecimalOnly(raw) {
    const s = (raw ?? '').trim().replace(/\s+/g, '');
    if (!s) return { error: 'Please enter a value.' };
    const v = Number(s);
    if (!Number.isFinite(v)) return { error: 'That does not look like a valid number.' };
    return { value: v };
  }

  function decClose(inputVal, targetVal, relTol = REL_TOL) {
    const denom = Math.max(1e-12, Math.abs(targetVal));
    return Math.abs(inputVal - targetVal) <= relTol * denom;
  }

  function buildType1BinomialProblem() {
    const y = randInt(4, 20);
    const n = randInt(6, 50);

    // success definition
    let successText = '';
    let p = 0;

    if (Math.random() < 0.3) {
      const z = randInt(1, y);
      p = 1 / y;
      successText = `rolling a ${z}`;
    } else {
      const dir = (Math.random() < 0.5) ? 'higher' : 'lower';
      if (dir === 'higher') {
        const t = randInt(1, y - 1);
        p = (y - t) / y;
        successText = `rolling higher than ${t}`;
      } else {
        const t = randInt(2, y);
        p = (t - 1) / y;
        successText = `rolling lower than ${t}`;
      }
    }

    // Stage 1 target x
    const x1 = randInt(0, n);

    // Stage 2: choose an event that requires summing 2 or 3 pmf values, with 50% chance of using a complement.
    const wantComplement = Math.random() < 0.5;
    const wantUpperTail = Math.random() < 0.5; // true => easy tail on the right
    const includeEqual = Math.random() < 0.5;
    const termCount = (Math.random() < 0.5) ? 2 : 3;
    const m = termCount - 1;
    const easyRight = wantUpperTail;

    const sumP = (xs) => xs.reduce((acc, x) => acc + binomPMF(n, p, x), 0);
    const easyXs = easyRight
      ? Array.from({ length: termCount }, (_, i) => n - m + i)
      : Array.from({ length: termCount }, (_, i) => i);
    const easySum = sumP(easyXs);

    let stage2Prompt = '';
    let stage2SolutionTex = '';
    let stage2Target = 0;
    const redXs = [...easyXs];

    const fmt = (v) => v.toFixed(3);

    if (!wantComplement) {
      if (easyRight) {
        const k = n - m;
        const sym = includeEqual ? '\\ge' : '>';
        const thresh = includeEqual ? k : (k - 1);
        stage2Prompt = `What is \\(P(X ${sym} ${thresh})\\)?`;
        stage2Target = easySum;
        stage2SolutionTex = `\\(P(X ${sym} ${thresh}) = ${easyXs.map(x => `f(${x};${n},p)`).join(' + ')} \\approx ${fmt(stage2Target)}\\)`;
      } else {
        const k = m;
        const sym = includeEqual ? '\\le' : '<';
        const thresh = includeEqual ? k : (k + 1);
        stage2Prompt = `What is \\(P(X ${sym} ${thresh})\\)?`;
        stage2Target = easySum;
        stage2SolutionTex = `\\(P(X ${sym} ${thresh}) = ${easyXs.map(x => `f(${x};${n},p)`).join(' + ')} \\approx ${fmt(stage2Target)}\\)`;
      }
    } else {
      stage2Target = 1 - easySum;
      if (easyRight) {
        const k = n - m;
        const sym = includeEqual ? '\\le' : '<';
        const thresh = includeEqual ? (k - 1) : k;
        stage2Prompt = `What is \\(P(X ${sym} ${thresh})\\)?`;
        stage2SolutionTex = `\\(P(X ${sym} ${thresh}) = 1 - P(X \\ge ${k}) = 1 - (${easyXs.map(x => `f(${x};${n},p)`).join(' + ')}) \\approx ${fmt(stage2Target)}\\)`;
      } else {
        const k = m;
        const sym = includeEqual ? '\\ge' : '>';
        const thresh = includeEqual ? (k + 1) : k;
        stage2Prompt = `What is \\(P(X ${sym} ${thresh})\\)?`;
        stage2SolutionTex = `\\(P(X ${sym} ${thresh}) = 1 - P(X \\le ${k}) = 1 - (${easyXs.map(x => `f(${x};${n},p)`).join(' + ')}) \\approx ${fmt(stage2Target)}\\)`;
      }
    }

    return {
      kind: 'binom_die',
      y, n, p, successText,
      x1,
      stage2Prompt,
      stage2Target,
      stage2SolutionTex,
      stage2RedXs: redXs
    };
  }

  function problemPrompt(p) {
    return `A ${p.y}-sided die is rolled ${p.n} times. A success will be considered ${p.successText}.`;
  }

  function renderStage() {
    if (!problem) return;
    tableArea.innerHTML = '';
    meanArea.innerHTML = '';
    setFeedback('');

    if (stage === 1) {
      workArea.innerHTML = `
        <div style="margin-bottom: 0.5rem;">Stage 1: What is the probability of \\(${problem.x1}\\) many successes?</div>
        <div>
          <label for="ans1">Answer (decimal):</label>
          <input id="ans1" type="text" inputmode="decimal" style="width: 10em; text-align: center;">
        </div>
      `;
      histogramArea.innerHTML = '';
    }

    if (stage === 2) {
      workArea.innerHTML = `
        <div style="margin-bottom: 0.5rem;">Stage 2: ${problem.stage2Prompt}</div>
        <div>
          <label for="ans2">Answer (decimal):</label>
          <input id="ans2" type="text" inputmode="decimal" style="width: 10em; text-align: center;">
        </div>
      `;
      histogramArea.innerHTML = '';
    }

    if (stage === 3) {
      workArea.innerHTML = `
        <div style="margin-bottom: 0.5rem;">Stage 3: Compute the mean \\((\\mu)\\) of \\(X\\).</div>
        <div>
          <label for="ans3">\\(\\mu =\\)</label>
          <input id="ans3" type="text" inputmode="decimal" style="width: 10em; text-align: center;">
        </div>
      `;
      histogramArea.innerHTML = '';
    }

    if (stage === 4) {
      workArea.innerHTML = `
        <div style="margin-bottom: 0.5rem;">Stage 4: Compute the standard deviation \\((\\sigma)\\) of \\(X\\).</div>
        <div>
          <label for="ans4">\\(\\sigma =\\)</label>
          <input id="ans4" type="text" inputmode="decimal" style="width: 10em; text-align: center;">
        </div>
      `;
      histogramArea.innerHTML = '';
    }

    typeset([workArea]);
  }

  function showStage1Solution() {
    const n = problem.n;
    const p = problem.p;
    const x = problem.x1;
    const val = binomPMF(n, p, x);
    const tex = `\\(P(X=${x}) = f(${x};${n},p) = \\binom{${n}}{${x}} p^{${x}}(1-p)^{${n}-${x}} \\approx ${val.toFixed(4)}\\)`;
    workArea.insertAdjacentHTML('beforeend', `<div style="margin-top: 0.75rem;">${tex}</div>`);
    renderBinomialHistogram(histogramArea, n, p, { highlightXs: [x], xLabel: 'x', yLabel: 'f(x)' });
    typeset([workArea]);
  }

  function showStage2Solution() {
    const n = problem.n;
    const p = problem.p;
    workArea.insertAdjacentHTML('beforeend', `<div style="margin-top: 0.75rem;">${problem.stage2SolutionTex}</div>`);
    renderBinomialHistogram(histogramArea, n, p, { highlightXs: problem.stage2RedXs, xLabel: 'x', yLabel: 'f(x)' });
    typeset([workArea]);
  }

  function showStage3Solution() {
    const mu = problem.n * problem.p;
    const tex = `\\(\\mu = np = ${problem.n}\\cdot ${problem.p.toFixed(6).replace(/0+$/,'').replace(/\\.$/,'')} \\approx ${mu.toFixed(4)}\\)`;
    workArea.insertAdjacentHTML('beforeend', `<div style="margin-top: 0.75rem;">${tex}</div>`);
    typeset([workArea]);
  }

  function showStage4Solution() {
    const sd = Math.sqrt(problem.n * problem.p * (1 - problem.p));
    const tex = `\\(\\sigma = \\sqrt{np(1-p)} = \\sqrt{${problem.n}\\cdot ${problem.p.toFixed(6).replace(/0+$/,'').replace(/\\.$/,'')}\\cdot ${(1-problem.p).toFixed(6).replace(/0+$/,'').replace(/\\.$/,'')}} \\approx ${sd.toFixed(4)}\\)`;
    workArea.insertAdjacentHTML('beforeend', `<div style="margin-top: 0.75rem;">${tex}</div>`);
    setFeedback('Done!', 'green');
    typeset([workArea]);
  }

  function checkAndAdvance(isHint = false) {
    if (!problem) return;

    let inputId = '';
    let target = 0;
    let after = () => {};

    if (stage === 1) {
      inputId = 'ans1';
      target = binomPMF(problem.n, problem.p, problem.x1);
      after = showStage1Solution;
    } else if (stage === 2) {
      inputId = 'ans2';
      target = problem.stage2Target;
      after = showStage2Solution;
    } else if (stage === 3) {
      inputId = 'ans3';
      target = problem.n * problem.p;
      after = showStage3Solution;
    } else if (stage === 4) {
      inputId = 'ans4';
      target = Math.sqrt(problem.n * problem.p * (1 - problem.p));
      after = showStage4Solution;
    } else {
      return;
    }

    if (!isHint) {
      const parsed = parseDecimalOnly(document.getElementById(inputId)?.value ?? '');
      if (parsed.error) {
        setFeedback(parsed.error, 'crimson');
        return;
      }
      if (!decClose(parsed.value, target, REL_TOL)) {
        setFeedback('Not quite.', 'crimson');
        return;
      }
      setFeedback('Correct!', 'green');
    } else {
      setFeedback('', 'black');
    }

    after();

    if (stage < 4) {
      stage += 1;
      workArea.insertAdjacentHTML('beforeend', `<hr style="margin: 1rem auto; max-width: 640px; opacity: 0.35;">`);
      histogramArea.innerHTML = '';
      renderStage();
    }
  }

  function startProblem() {
    clearActivity();
    problem = buildType1BinomialProblem();
    stage = 1;
    questionText.innerHTML = problemPrompt(problem);
    typeset([questionText]);
    renderStage();
  }

  startBtn.addEventListener('click', () => {
    playSound('click-sound');
    startProblem();
  });

  hintBtn.addEventListener('click', () => {
    playSound('click-sound');
    checkAndAdvance(true);
  });

  nextBtn.addEventListener('click', () => {
    playSound('click-sound');
    checkAndAdvance(false);
  });
</script>



  <audio id="click-sound" src="button.mp3" preload="auto"></audio>
  <audio id="set-sound" src="set2.mp3" preload="auto"></audio>

</body>
</html>
